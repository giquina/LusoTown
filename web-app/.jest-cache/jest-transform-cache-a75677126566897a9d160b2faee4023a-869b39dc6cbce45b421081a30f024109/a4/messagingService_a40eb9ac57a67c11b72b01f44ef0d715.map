{"version":3,"sources":["/workspaces/LusoTown/web-app/src/services/messagingService.ts"],"sourcesContent":["import { supabase } from '@/lib/supabase'\n\nexport interface MessagePermissionCheck {\n  can_message: boolean\n  has_mutual_match: boolean\n  has_event_permission: boolean\n  shared_events_count: number\n  reasons: string[]\n}\n\nexport interface Match {\n  id: string\n  user_id: string\n  target_user_id: string\n  match_type: 'compatibility' | 'professional' | 'cultural' | 'event_based'\n  compatibility_score: number\n  shared_interests: string[]\n  shared_events: string[]\n  status: 'pending' | 'liked' | 'passed' | 'blocked'\n  is_mutual: boolean\n  mutual_matched_at?: string\n  expires_at?: string\n  created_at: string\n  updated_at: string\n}\n\nexport interface Conversation {\n  id: string\n  participant_ids: string[]\n  connection_type: 'mutual_match' | 'event_based' | 'professional'\n  is_active: boolean\n  expires_at?: string\n  last_activity_at: string\n  created_at: string\n  updated_at: string\n}\n\nexport interface ConversationMessage {\n  id: string\n  conversation_id: string\n  sender_id: string\n  receiver_id: string\n  content: string\n  message_type: 'text' | 'image' | 'voice' | 'system'\n  approval_status: 'pending' | 'approved' | 'rejected' | 'auto_approved'\n  is_read: boolean\n  is_blocked: boolean\n  blocked_reason?: string\n  safety_score: number\n  contains_contact_info: boolean\n  flagged_content: any\n  response_deadline?: string\n  created_at: string\n  updated_at: string\n}\n\nclass MessagingService {\n  private supabaseClient = supabase\n\n  /**\n   * Check if two users can message each other\n   */\n  async checkMessagePermission(targetUserId: string): Promise<MessagePermissionCheck> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .rpc('can_users_message', {\n        user_a: user.user.id,\n        user_b: targetUserId\n      })\n\n    if (error) throw error\n\n    return data as MessagePermissionCheck\n  }\n\n  /**\n   * Get user's mutual matches with messaging permissions\n   */\n  async getMutualMatches(): Promise<Match[]> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .from('user_matches')\n      .select(`\n        *,\n        target_user:profiles!target_user_id(\n          id,\n          first_name,\n          last_name,\n          profile_picture_url,\n          location,\n          membership_tier,\n          verification_status\n        )\n      `)\n      .eq('user_id', user.user.id)\n      .eq('is_mutual', true)\n      .eq('status', 'liked')\n      .order('mutual_matched_at', { ascending: false })\n\n    if (error) throw error\n    return data || []\n  }\n\n  /**\n   * Get users from shared events with messaging permissions\n   */\n  async getEventBasedContacts(): Promise<any[]> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .from('messaging_permissions')\n      .select(`\n        *,\n        target_user:profiles!target_user_id(\n          id,\n          first_name,\n          last_name,\n          profile_picture_url,\n          location,\n          membership_tier,\n          verification_status\n        ),\n        event:events!source_id(\n          id,\n          title,\n          start_datetime,\n          location\n        )\n      `)\n      .eq('user_id', user.user.id)\n      .eq('permission_type', 'event_based')\n      .eq('is_active', true)\n      .order('granted_at', { ascending: false })\n\n    if (error) throw error\n    return data || []\n  }\n\n  /**\n   * Create or get existing conversation between two users\n   */\n  async getOrCreateConversation(targetUserId: string): Promise<Conversation> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    // Check permission first\n    const permission = await this.checkMessagePermission(targetUserId)\n    if (!permission.can_message) {\n      throw new Error('No permission to message this user. You must be matched or have attended the same event.')\n    }\n\n    // Check for existing conversation\n    const { data: existingConversation } = await this.supabaseClient\n      .from('conversations')\n      .select('*')\n      .contains('participant_ids', [user.user.id])\n      .contains('participant_ids', [targetUserId])\n      .eq('is_active', true)\n      .single()\n\n    if (existingConversation) {\n      return existingConversation\n    }\n\n    // Create new conversation\n    const connectionType = permission.has_mutual_match ? 'mutual_match' : \n                          permission.has_event_permission ? 'event_based' : 'professional'\n\n    const { data: newConversation, error } = await this.supabaseClient\n      .from('conversations')\n      .insert({\n        participant_ids: [user.user.id, targetUserId],\n        connection_type: connectionType\n      })\n      .select()\n      .single()\n\n    if (error) throw error\n    return newConversation\n  }\n\n  /**\n   * Send a message in a conversation\n   */\n  async sendMessage(\n    conversationId: string, \n    receiverId: string, \n    content: string, \n    messageType: 'text' | 'image' | 'voice' = 'text'\n  ): Promise<ConversationMessage> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    // The trigger function will validate permissions automatically\n    const { data, error } = await this.supabaseClient\n      .from('conversation_messages')\n      .insert({\n        conversation_id: conversationId,\n        sender_id: user.user.id,\n        receiver_id: receiverId,\n        content,\n        message_type: messageType\n      })\n      .select()\n      .single()\n\n    if (error) {\n      if (error.message.includes('not authorized to message')) {\n        throw new Error('You can only message users you are matched with or have attended events together.')\n      }\n      throw error\n    }\n\n    // Update conversation last activity\n    await this.supabaseClient\n      .from('conversations')\n      .update({ last_activity_at: new Date().toISOString() })\n      .eq('id', conversationId)\n\n    return data\n  }\n\n  /**\n   * Get messages for a conversation\n   */\n  async getConversationMessages(conversationId: string): Promise<ConversationMessage[]> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .from('conversation_messages')\n      .select(`\n        *,\n        sender:profiles!sender_id(\n          id,\n          first_name,\n          last_name,\n          profile_picture_url\n        ),\n        receiver:profiles!receiver_id(\n          id,\n          first_name,\n          last_name,\n          profile_picture_url\n        )\n      `)\n      .eq('conversation_id', conversationId)\n      .in('approval_status', ['approved', 'auto_approved'])\n      .eq('is_blocked', false)\n      .order('created_at', { ascending: true })\n\n    if (error) throw error\n    return data || []\n  }\n\n  /**\n   * Get user's active conversations\n   */\n  async getUserConversations(): Promise<any[]> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .from('conversations')\n      .select(`\n        *,\n        conversation_messages!inner(\n          id,\n          content,\n          sender_id,\n          created_at,\n          is_read,\n          approval_status\n        )\n      `)\n      .contains('participant_ids', [user.user.id])\n      .eq('is_active', true)\n      .order('last_activity_at', { ascending: false })\n\n    if (error) throw error\n\n    // Get participant details for each conversation\n    const conversationsWithParticipants = await Promise.all(\n      (data || []).map(async (conversation) => {\n        const otherParticipantId = conversation.participant_ids.find(\n          (id: string) => id !== user.user.id\n        )\n\n        const { data: participant } = await this.supabaseClient\n          .from('profiles')\n          .select('id, first_name, last_name, profile_picture_url, location')\n          .eq('id', otherParticipantId)\n          .single()\n\n        return {\n          ...conversation,\n          other_participant: participant,\n          last_message: conversation.conversation_messages?.[0] || null,\n          unread_count: conversation.conversation_messages?.filter(\n            (msg: any) => !msg.is_read && msg.sender_id !== user.user.id\n          ).length || 0\n        }\n      })\n    )\n\n    return conversationsWithParticipants\n  }\n\n  /**\n   * Mark messages as read\n   */\n  async markMessagesAsRead(conversationId: string): Promise<void> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { error } = await this.supabaseClient\n      .from('conversation_messages')\n      .update({ is_read: true })\n      .eq('conversation_id', conversationId)\n      .eq('receiver_id', user.user.id)\n      .eq('is_read', false)\n\n    if (error) throw error\n  }\n\n  /**\n   * Like a user (for matching)\n   */\n  async likeUser(targetUserId: string): Promise<Match> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .from('user_matches')\n      .insert({\n        user_id: user.user.id,\n        target_user_id: targetUserId,\n        status: 'liked'\n      })\n      .select()\n      .single()\n\n    if (error) {\n      if (error.code === '23505') { // Unique constraint violation\n        throw new Error('You have already interacted with this user')\n      }\n      throw error\n    }\n\n    return data\n  }\n\n  /**\n   * Pass on a user (for matching)\n   */\n  async passUser(targetUserId: string): Promise<Match> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { data, error } = await this.supabaseClient\n      .from('user_matches')\n      .insert({\n        user_id: user.user.id,\n        target_user_id: targetUserId,\n        status: 'passed'\n      })\n      .select()\n      .single()\n\n    if (error) {\n      if (error.code === '23505') {\n        throw new Error('You have already interacted with this user')\n      }\n      throw error\n    }\n\n    return data\n  }\n\n  /**\n   * Report inappropriate message\n   */\n  async reportMessage(messageId: string, reason: string): Promise<void> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    const { error } = await this.supabaseClient\n      .from('conversation_messages')\n      .update({ \n        is_blocked: true,\n        blocked_reason: `Reported by user: ${reason}`\n      })\n      .eq('id', messageId)\n\n    if (error) throw error\n\n    // Also add to moderation queue\n    const { error: moderationError } = await this.supabaseClient\n      .from('moderation_queue')\n      .insert({\n        message_id: messageId,\n        flagged_reasons: [reason],\n        priority_level: 'high'\n      })\n\n    if (moderationError) throw moderationError\n  }\n\n  /**\n   * Block a user\n   */\n  async blockUser(targetUserId: string): Promise<void> {\n    const { data: user } = await this.supabaseClient.auth.getUser()\n    if (!user.user) throw new Error('User not authenticated')\n\n    // Update any existing matches to blocked status\n    const { error: matchError } = await this.supabaseClient\n      .from('user_matches')\n      .update({ status: 'blocked' })\n      .or(`and(user_id.eq.${user.user.id},target_user_id.eq.${targetUserId}),and(user_id.eq.${targetUserId},target_user_id.eq.${user.user.id})`)\n\n    if (matchError) throw matchError\n\n    // Deactivate messaging permissions\n    const { error: permissionError } = await this.supabaseClient\n      .from('messaging_permissions')\n      .update({ is_active: false })\n      .or(`and(user_id.eq.${user.user.id},target_user_id.eq.${targetUserId}),and(user_id.eq.${targetUserId},target_user_id.eq.${user.user.id})`)\n\n    if (permissionError) throw permissionError\n\n    // Deactivate conversations\n    const { error: conversationError } = await this.supabaseClient\n      .from('conversations')\n      .update({ is_active: false })\n      .contains('participant_ids', [user.user.id])\n      .contains('participant_ids', [targetUserId])\n\n    if (conversationError) throw conversationError\n  }\n}\n\nexport const messagingService = new MessagingService()"],"names":["messagingService","MessagingService","checkMessagePermission","targetUserId","data","user","supabaseClient","auth","getUser","Error","error","rpc","user_a","id","user_b","getMutualMatches","from","select","eq","order","ascending","getEventBasedContacts","getOrCreateConversation","permission","can_message","existingConversation","contains","single","connectionType","has_mutual_match","has_event_permission","newConversation","insert","participant_ids","connection_type","sendMessage","conversationId","receiverId","content","messageType","conversation_id","sender_id","receiver_id","message_type","message","includes","update","last_activity_at","Date","toISOString","getConversationMessages","in","getUserConversations","conversationsWithParticipants","Promise","all","map","conversation","otherParticipantId","find","participant","other_participant","last_message","conversation_messages","unread_count","filter","msg","is_read","length","markMessagesAsRead","likeUser","user_id","target_user_id","status","code","passUser","reportMessage","messageId","reason","is_blocked","blocked_reason","moderationError","message_id","flagged_reasons","priority_level","blockUser","matchError","or","permissionError","is_active","conversationError","supabase"],"mappings":"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"}