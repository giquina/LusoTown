{"version":3,"sources":["/workspaces/LusoTown/web-app/src/i18n/index.ts"],"sourcesContent":["// Translation loader and management utility\nexport type Language = 'en' | 'pt'\n\n// Translation cache to avoid repeated JSON parsing\nlet translationCache: Record<Language, Record<string, string>> = {} as Record<Language, Record<string, string>>\n\n/**\n * Dynamically loads translation files only when needed\n * This reduces initial bundle size by lazy-loading translations\n */\nexport async function loadTranslations(language: Language): Promise<Record<string, string>> {\n  // Return cached translations if already loaded\n  if (translationCache[language]) {\n    return translationCache[language]\n  }\n\n  try {\n    // Dynamic import to enable code splitting\n    const translations = await import(`./${language}.json`)\n    translationCache[language] = translations.default\n    return translations.default\n  } catch (error) {\n    console.error(`Failed to load translations for language: ${language}`, error)\n    \n    // Fallback to English if Lusophone fails to load\n    if (language === 'pt') {\n      return loadTranslations('en')\n    }\n    \n    // Return empty object as final fallback\n    return {}\n  }\n}\n\n/**\n * Translation function with fallback support\n * @param translations - The loaded translations object\n * @param key - Translation key (e.g., 'hero.title')\n * @param fallback - Optional fallback text if key is not found\n * @returns Translated string or fallback\n */\nexport function translateKey(\n  translations: Record<string, string>, \n  key: string, \n  fallback?: string\n): string {\n  const value = translations[key]\n  \n  if (value !== undefined) {\n    return value\n  }\n  \n  // Return fallback or the key itself for debugging\n  return fallback || key\n}\n\n/**\n * Preload translations for better performance\n * Call this during app initialization to cache translations\n */\nexport async function preloadTranslations(): Promise<void> {\n  try {\n    await Promise.all([\n      loadTranslations('en'),\n      loadTranslations('pt')\n    ])\n  } catch (error) {\n    console.error('Failed to preload translations:', error)\n  }\n}\n\n/**\n * Clear translation cache (useful for testing or memory management)\n */\nexport function clearTranslationCache(): void {\n  translationCache = {} as Record<Language, Record<string, string>>\n}\n\n/**\n * Get available languages\n */\nexport function getAvailableLanguages(): Language[] {\n  return ['en', 'pt']\n}\n\n/**\n * Validate if a language is supported\n */\nexport function isValidLanguage(lang: string): lang is Language {\n  return getAvailableLanguages().includes(lang as Language)\n}"],"names":["clearTranslationCache","getAvailableLanguages","isValidLanguage","loadTranslations","preloadTranslations","translateKey","translationCache","language","translations","default","error","console","key","fallback","value","undefined","Promise","all","lang","includes"],"mappings":"AAAA,4CAA4C;;;;;;;;;;;;IA0E5BA,qBAAqB;eAArBA;;IAOAC,qBAAqB;eAArBA;;IAOAC,eAAe;eAAfA;;IA9EMC,gBAAgB;eAAhBA;;IAkDAC,mBAAmB;eAAnBA;;IAnBNC,YAAY;eAAZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtChB,mDAAmD;AACnD,IAAIC,mBAA6D,CAAC;AAM3D,eAAeH,iBAAiBI,QAAkB;IACvD,+CAA+C;IAC/C,IAAID,gBAAgB,CAACC,SAAS,EAAE;QAC9B,OAAOD,gBAAgB,CAACC,SAAS;IACnC;IAEA,IAAI;QACF,0CAA0C;QAC1C,MAAMC,eAAe,MAAM,gBAAO,CAAC,EAAE,EAAED,SAAS,KAAK,CAAC,oDAA3B;QAC3BD,gBAAgB,CAACC,SAAS,GAAGC,aAAaC,OAAO;QACjD,OAAOD,aAAaC,OAAO;IAC7B,EAAE,OAAOC,OAAO;QACdC,QAAQD,KAAK,CAAC,CAAC,0CAA0C,EAAEH,SAAS,CAAC,EAAEG;QAEvE,iDAAiD;QACjD,IAAIH,aAAa,MAAM;YACrB,OAAOJ,iBAAiB;QAC1B;QAEA,wCAAwC;QACxC,OAAO,CAAC;IACV;AACF;AASO,SAASE,aACdG,YAAoC,EACpCI,GAAW,EACXC,QAAiB;IAEjB,MAAMC,QAAQN,YAAY,CAACI,IAAI;IAE/B,IAAIE,UAAUC,WAAW;QACvB,OAAOD;IACT;IAEA,kDAAkD;IAClD,OAAOD,YAAYD;AACrB;AAMO,eAAeR;IACpB,IAAI;QACF,MAAMY,QAAQC,GAAG,CAAC;YAChBd,iBAAiB;YACjBA,iBAAiB;SAClB;IACH,EAAE,OAAOO,OAAO;QACdC,QAAQD,KAAK,CAAC,mCAAmCA;IACnD;AACF;AAKO,SAASV;IACdM,mBAAmB,CAAC;AACtB;AAKO,SAASL;IACd,OAAO;QAAC;QAAM;KAAK;AACrB;AAKO,SAASC,gBAAgBgB,IAAY;IAC1C,OAAOjB,wBAAwBkB,QAAQ,CAACD;AAC1C"}