{"version":3,"sources":["/workspaces/LusoTown/web-app/src/context/CartContext.tsx"],"sourcesContent":["'use client'\n\nimport { createContext, useContext, useState, ReactNode, useEffect, useCallback, useMemo } from 'react'\nimport { toast } from 'react-hot-toast'\n\nexport interface CartItem {\n  id: string\n  type: 'event' | 'business_service' | 'product' | 'transport_service' | 'premium_service'\n  title: string\n  description?: string\n  price: number\n  currency: string\n  imageUrl?: string\n  quantity: number\n  maxQuantity?: number\n  \n  // Event-specific fields\n  eventDate?: string\n  eventTime?: string\n  eventLocation?: string\n  eventCategory?: string\n  spotsLeft?: number\n  requiresApproval?: boolean\n  membershipRequired?: 'free' | 'core' | 'premium'\n  \n  // Business-specific fields\n  businessName?: string\n  businessCategory?: string\n  serviceType?: string\n  \n  // Transport service fields\n  transportServiceId?: string\n  vehicleId?: string\n  driverId?: string\n  pickupDateTime?: string\n  pickupLocation?: string\n  dropoffLocation?: string\n  hours?: number\n  bookingType?: 'hourly' | 'day_rate' | 'block_booking' | 'airport_transfer'\n  passengerCount?: number\n  pricingBreakdown?: any\n  \n  // Additional metadata\n  addedAt: string\n  expiresAt?: string // For time-sensitive items\n  metadata?: Record<string, any>\n}\n\nexport interface SavedItem {\n  id: string\n  type: 'event' | 'business' | 'feed' | 'group'\n  title: string\n  description?: string\n  imageUrl?: string\n  category?: string\n  savedAt: string\n  metadata?: Record<string, any>\n  \n  // Event-specific\n  eventDate?: string\n  eventTime?: string\n  eventLocation?: string\n  eventPrice?: number\n  \n  // Business-specific\n  businessName?: string\n  businessRating?: number\n  businessLocation?: string\n}\n\nexport interface ReservationRequest {\n  itemId: string\n  itemType: 'event'\n  quantity: number\n  userNotes?: string\n  dietaryRequirements?: string[]\n  emergencyContact?: {\n    name: string\n    phone: string\n    relationship: string\n  }\n}\n\ninterface CartContextType {\n  // Cart functionality\n  cartItems: CartItem[]\n  cartCount: number\n  cartTotal: number\n  addToCart: (item: Omit<CartItem, 'id' | 'quantity' | 'addedAt'> & { quantity?: number }) => void\n  removeFromCart: (id: string) => void\n  updateQuantity: (id: string, quantity: number) => void\n  clearCart: () => void\n  \n  // Saved items functionality\n  savedItems: SavedItem[]\n  savedCount: number\n  addToSaved: (item: Omit<SavedItem, 'id' | 'savedAt'>) => void\n  removeFromSaved: (id: string) => void\n  isSaved: (id: string) => boolean\n  toggleSaved: (item: Omit<SavedItem, 'id' | 'savedAt'>) => void\n  \n  // Reservations\n  pendingReservations: ReservationRequest[]\n  createReservation: (request: ReservationRequest) => Promise<{ success: boolean; message: string }>\n  \n  // Utility functions\n  isInCart: (id: string) => boolean\n  getCartItem: (id: string) => CartItem | undefined\n  getSavedItem: (id: string) => SavedItem | undefined\n}\n\nconst CartContext = createContext<CartContextType | undefined>(undefined)\n\nexport function CartProvider({ children }: { children: ReactNode }) {\n  const [cartItems, setCartItems] = useState<CartItem[]>([])\n  const [savedItems, setSavedItems] = useState<SavedItem[]>([])\n  const [pendingReservations, setPendingReservations] = useState<ReservationRequest[]>([])\n\n  // Load from localStorage on mount with error handling\n  useEffect(() => {\n    try {\n      const savedCart = localStorage.getItem('lusotown-cart')\n      const savedFavorites = localStorage.getItem('lusotown-saved')\n      const savedReservations = localStorage.getItem('lusotown-reservations')\n      \n      if (savedCart) {\n        const parsedCart = JSON.parse(savedCart)\n        // Validate cart items structure\n        if (Array.isArray(parsedCart)) {\n          setCartItems(parsedCart)\n        }\n      }\n      if (savedFavorites) {\n        const parsedFavorites = JSON.parse(savedFavorites)\n        // Validate saved items structure\n        if (Array.isArray(parsedFavorites)) {\n          setSavedItems(parsedFavorites)\n        }\n      }\n      if (savedReservations) {\n        const parsedReservations = JSON.parse(savedReservations)\n        // Validate reservations structure\n        if (Array.isArray(parsedReservations)) {\n          setPendingReservations(parsedReservations)\n        }\n      }\n    } catch (error) {\n      console.error('Error loading cart/saved data:', error)\n      // Clear corrupted data\n      localStorage.removeItem('lusotown-cart')\n      localStorage.removeItem('lusotown-saved')\n      localStorage.removeItem('lusotown-reservations')\n    }\n  }, [])\n\n  // Save to localStorage when data changes with error handling\n  useEffect(() => {\n    try {\n      localStorage.setItem('lusotown-cart', JSON.stringify(cartItems))\n    } catch (error) {\n      console.error('Error saving cart to localStorage:', error)\n    }\n  }, [cartItems])\n\n  useEffect(() => {\n    try {\n      localStorage.setItem('lusotown-saved', JSON.stringify(savedItems))\n    } catch (error) {\n      console.error('Error saving favorites to localStorage:', error)\n    }\n  }, [savedItems])\n\n  useEffect(() => {\n    try {\n      localStorage.setItem('lusotown-reservations', JSON.stringify(pendingReservations))\n    } catch (error) {\n      console.error('Error saving reservations to localStorage:', error)\n    }\n  }, [pendingReservations])\n\n  // Cart functions - memoized to prevent unnecessary re-renders\n  const addToCart = useCallback((item: Omit<CartItem, 'id' | 'quantity' | 'addedAt'> & { quantity?: number }) => {\n    const newItem: CartItem = {\n      ...item,\n      id: `cart-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      quantity: item.quantity || 1,\n      addedAt: new Date().toISOString()\n    }\n    \n    // Check if item already exists (for events, don't allow duplicates)\n    const existingItem = cartItems.find(cartItem => \n      cartItem.type === newItem.type && \n      cartItem.title === newItem.title &&\n      (newItem.type === 'event' ? cartItem.eventDate === newItem.eventDate : true)\n    )\n    \n    if (existingItem && newItem.type === 'event') {\n      toast.error('Este evento já está no teu carrinho')\n      return\n    }\n    \n    if (existingItem) {\n      updateQuantity(existingItem.id, existingItem.quantity + newItem.quantity)\n      return\n    }\n    \n    // Check availability for events\n    if (newItem.type === 'event' && newItem.spotsLeft !== undefined) {\n      if (newItem.spotsLeft < newItem.quantity) {\n        toast.error(`Apenas ${newItem.spotsLeft} vagas disponíveis`)\n        return\n      }\n    }\n    \n    setCartItems(prev => [...prev, newItem])\n    toast.success('Adicionado ao carrinho', {\n      icon: '🛒',\n      duration: 2000\n    })\n  }, [cartItems])\n\n  const removeFromCart = useCallback((id: string) => {\n    setCartItems(prev => prev.filter(item => item.id !== id))\n    toast.success('Removido do carrinho')\n  }, [])\n\n  const updateQuantity = useCallback((id: string, quantity: number) => {\n    if (quantity <= 0) {\n      removeFromCart(id)\n      return\n    }\n    \n    setCartItems(prev => prev.map(item => {\n      if (item.id === id) {\n        // Check max quantity constraints\n        if (item.maxQuantity && quantity > item.maxQuantity) {\n          toast.error(`Máximo ${item.maxQuantity} unidades`)\n          return item\n        }\n        \n        // Check spots availability for events\n        if (item.type === 'event' && item.spotsLeft !== undefined && quantity > item.spotsLeft) {\n          toast.error(`Apenas ${item.spotsLeft} vagas disponíveis`)\n          return item\n        }\n        \n        return { ...item, quantity }\n      }\n      return item\n    }))\n  }, [removeFromCart])\n\n  const clearCart = useCallback(() => {\n    setCartItems([])\n    toast.success('Carrinho limpo')\n  }, [])\n\n  // Saved items functions\n  const addToSaved = useCallback((item: Omit<SavedItem, 'id' | 'savedAt'>) => {\n    // Check if already saved\n    if (savedItems.some(saved => saved.type === item.type && saved.title === item.title)) {\n      toast.error('Item já guardado nos favoritos')\n      return\n    }\n    \n    const newSavedItem: SavedItem = {\n      ...item,\n      id: `saved-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      savedAt: new Date().toISOString()\n    }\n    \n    setSavedItems(prev => [...prev, newSavedItem])\n    toast.success('Guardado nos favoritos', {\n      icon: '❤️',\n      duration: 2000\n    })\n  }, [savedItems])\n\n  const removeFromSaved = useCallback((id: string) => {\n    setSavedItems(prev => prev.filter(item => item.id !== id))\n    toast.success('Removido dos favoritos')\n  }, [])\n\n  const isSaved = useCallback((title: string) => {\n    return savedItems.some(item => item.title === title)\n  }, [savedItems])\n\n  const toggleSaved = useCallback((item: Omit<SavedItem, 'id' | 'savedAt'>) => {\n    const existing = savedItems.find(saved => saved.title === item.title)\n    if (existing) {\n      removeFromSaved(existing.id)\n    } else {\n      addToSaved(item)\n    }\n  }, [savedItems, removeFromSaved, addToSaved])\n\n  // Reservation functions\n  const createReservation = useCallback(async (request: ReservationRequest): Promise<{ success: boolean; message: string }> => {\n    try {\n      // Check if item is in cart\n      const cartItem = cartItems.find(item => \n        item.type === request.itemType && item.title.includes(request.itemId)\n      )\n      \n      if (!cartItem) {\n        return { success: false, message: 'Item não encontrado no carrinho' }\n      }\n      \n      // Validate quantity\n      if (request.quantity > cartItem.quantity) {\n        return { success: false, message: 'Quantidade inválida' }\n      }\n      \n      // Check if reservation already exists\n      const existingReservation = pendingReservations.find(res => res.itemId === request.itemId)\n      if (existingReservation) {\n        return { success: false, message: 'Reserva já existe para este item' }\n      }\n      \n      // Create reservation\n      setPendingReservations(prev => [...prev, request])\n      \n      // Remove from cart (move to reservations)\n      removeFromCart(cartItem.id)\n      \n      toast.success('Reserva criada com sucesso! Aguarda confirmação.', {\n        icon: '📅',\n        duration: 4000\n      })\n      \n      return { success: true, message: 'Reserva criada com sucesso' }\n    } catch (error) {\n      console.error('Error creating reservation:', error)\n      return { success: false, message: 'Erro ao criar reserva' }\n    }\n  }, [cartItems, pendingReservations, removeFromCart])\n\n  // Utility functions\n  const isInCart = useCallback((title: string) => {\n    return cartItems.some(item => item.title === title)\n  }, [cartItems])\n\n  const getCartItem = useCallback((id: string) => {\n    return cartItems.find(item => item.id === id)\n  }, [cartItems])\n\n  const getSavedItem = useCallback((id: string) => {\n    return savedItems.find(item => item.id === id)\n  }, [savedItems])\n\n  // Computed values - memoized for performance\n  const cartCount = useMemo(() => \n    cartItems.reduce((total, item) => total + item.quantity, 0), \n    [cartItems]\n  )\n  \n  const cartTotal = useMemo(() => \n    cartItems.reduce((total, item) => total + (item.price * item.quantity), 0), \n    [cartItems]\n  )\n  \n  const savedCount = useMemo(() => savedItems.length, [savedItems])\n\n  // Memoize context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    cartItems,\n    cartCount,\n    cartTotal,\n    addToCart,\n    removeFromCart,\n    updateQuantity,\n    clearCart,\n    savedItems,\n    savedCount,\n    addToSaved,\n    removeFromSaved,\n    isSaved,\n    toggleSaved,\n    pendingReservations,\n    createReservation,\n    isInCart,\n    getCartItem,\n    getSavedItem\n  }), [\n    cartItems,\n    cartCount,\n    cartTotal,\n    addToCart,\n    removeFromCart,\n    updateQuantity,\n    clearCart,\n    savedItems,\n    savedCount,\n    addToSaved,\n    removeFromSaved,\n    isSaved,\n    toggleSaved,\n    pendingReservations,\n    createReservation,\n    isInCart,\n    getCartItem,\n    getSavedItem\n  ])\n\n  return (\n    <CartContext.Provider value={contextValue}>\n      {children}\n    </CartContext.Provider>\n  )\n}\n\nexport function useCart() {\n  const context = useContext(CartContext)\n  if (context === undefined) {\n    throw new Error('useCart must be used within a CartProvider')\n  }\n  return context\n}"],"names":["CartProvider","useCart","CartContext","createContext","undefined","children","cartItems","setCartItems","useState","savedItems","setSavedItems","pendingReservations","setPendingReservations","useEffect","savedCart","localStorage","getItem","savedFavorites","savedReservations","parsedCart","JSON","parse","Array","isArray","parsedFavorites","parsedReservations","error","console","removeItem","setItem","stringify","addToCart","useCallback","item","newItem","id","Date","now","Math","random","toString","substr","quantity","addedAt","toISOString","existingItem","find","cartItem","type","title","eventDate","toast","updateQuantity","spotsLeft","prev","success","icon","duration","removeFromCart","filter","map","maxQuantity","clearCart","addToSaved","some","saved","newSavedItem","savedAt","removeFromSaved","isSaved","toggleSaved","existing","createReservation","request","itemType","includes","itemId","message","existingReservation","res","isInCart","getCartItem","getSavedItem","cartCount","useMemo","reduce","total","cartTotal","price","savedCount","length","contextValue","Provider","value","context","useContext","Error"],"mappings":"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"}