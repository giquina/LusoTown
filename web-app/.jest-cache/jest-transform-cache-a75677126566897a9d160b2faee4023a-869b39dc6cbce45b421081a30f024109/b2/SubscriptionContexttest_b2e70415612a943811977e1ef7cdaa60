54bd667866e1dbc142b5187b87606af8
"use strict";
// Mock Stripe
jest.mock("@stripe/stripe-js", ()=>({
        loadStripe: jest.fn(()=>Promise.resolve({
                redirectToCheckout: jest.fn()
            }))
    }));
// Mock auth service
jest.mock("@/lib/auth", ()=>({
        authService: {
            getCurrentUser: jest.fn(),
            isDemoUser: jest.fn(()=>false),
            onAuthStateChange: jest.fn(()=>jest.fn())
        }
    }));
// Mock Supabase
jest.mock("@/lib/supabase", ()=>({
        supabase: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn(()=>Promise.resolve({
                                            data: null,
                                            error: null
                                        }))
                                }))
                        })),
                    insert: jest.fn(()=>Promise.resolve({
                            data: null,
                            error: null
                        })),
                    update: jest.fn(()=>({
                            eq: jest.fn(()=>Promise.resolve({
                                    data: null,
                                    error: null
                                }))
                        }))
                }))
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _SubscriptionContext = require("../../src/context/SubscriptionContext");
const _LanguageContext = require("../../src/context/LanguageContext");
const _testutils = require("../utils/test-utils");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock fetch for API calls
global.fetch = jest.fn();
describe("SubscriptionContext", ()=>{
    const mockUser = {
        id: "test-user",
        email: "test@example.com",
        name: "Test User"
    };
    const wrapper = ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_LanguageContext.LanguageProvider, {
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_SubscriptionContext.SubscriptionProvider, {
                children: children
            })
        });
    beforeEach(()=>{
        jest.clearAllMocks();
        const { authService } = require("@/lib/auth");
        authService.getCurrentUser.mockReturnValue(mockUser);
        authService.isDemoUser.mockReturnValue(false);
    });
    describe("Initialization", ()=>{
        it("should initialize with loading state", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            expect(result.current.isLoading).toBe(true);
            expect(result.current.subscription).toBeNull();
            expect(result.current.hasActiveSubscription).toBe(false);
        });
        it("should handle demo user correctly", ()=>{
            const { authService } = require("@/lib/auth");
            authService.isDemoUser.mockReturnValue(true);
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            expect(result.current.subscriptionRequired).toBe(false);
        });
    });
    describe("Subscription Management", ()=>{
        it("should create subscription with correct tier", async ()=>{
            const mockFetch = global.fetch;
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: ()=>Promise.resolve({
                        sessionId: "test-session-id"
                    })
            });
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            await (0, _react1.act)(async ()=>{
                const sessionId = await result.current.createSubscription("ambassador");
                expect(sessionId).toBe("test-session-id");
            });
            expect(mockFetch).toHaveBeenCalledWith("/api/create-subscription", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    userId: mockUser.id,
                    userEmail: mockUser.email,
                    userName: mockUser.name,
                    tier: "ambassador"
                })
            });
        });
        it("should handle subscription creation failure", async ()=>{
            const mockFetch = global.fetch;
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400
            });
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            await (0, _react1.act)(async ()=>{
                const sessionId = await result.current.createSubscription("community");
                expect(sessionId).toBeNull();
            });
        });
        it("should upgrade subscription successfully", async ()=>{
            const mockFetch = global.fetch;
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: ()=>Promise.resolve({})
            });
            // Set up existing subscription
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            // Mock existing subscription
            (0, _react1.act)(()=>{
                result.current.subscription = _testutils.portugueseTestUtils.mockPremiumSubscription;
            });
            await (0, _react1.act)(async ()=>{
                const success = await result.current.upgradeSubscription("ambassador");
                expect(success).toBe(true);
            });
            expect(mockFetch).toHaveBeenCalledWith("/api/upgrade-subscription", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    subscriptionId: undefined,
                    newTier: "ambassador"
                })
            });
        });
        it("should cancel subscription successfully", async ()=>{
            const mockFetch = global.fetch;
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: ()=>Promise.resolve({})
            });
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            // Mock existing subscription
            (0, _react1.act)(()=>{
                result.current.subscription = _testutils.portugueseTestUtils.mockPremiumSubscription;
            });
            await (0, _react1.act)(async ()=>{
                const success = await result.current.cancelSubscription();
                expect(success).toBe(true);
            });
            expect(mockFetch).toHaveBeenCalledWith("/api/cancel-subscription", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    subscriptionId: undefined
                })
            });
        });
    });
    describe("Membership Tiers and Discounts", ()=>{
        it("should calculate correct service discount for each tier", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            // Test different tiers
            const tiers = [
                {
                    tier: "community",
                    expectedDiscount: 10
                },
                {
                    tier: "silver",
                    expectedDiscount: 15
                },
                {
                    tier: "gold",
                    expectedDiscount: 20
                },
                {
                    tier: "ambassador",
                    expectedDiscount: 25
                }
            ];
            tiers.forEach(({ tier, expectedDiscount })=>{
                (0, _react1.act)(()=>{
                    result.current.subscription = {
                        ..._testutils.portugueseTestUtils.mockPremiumSubscription,
                        tier,
                        status: "active",
                        current_period_end: "2025-01-01T00:00:00Z"
                    };
                });
                expect(result.current.serviceDiscount).toBe(expectedDiscount);
                expect(result.current.membershipTier).toBe(tier);
            });
        });
        it("should return no discount for inactive subscription", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            expect(result.current.serviceDiscount).toBe(0);
            expect(result.current.membershipTier).toBe("none");
        });
    });
    describe("Trial Management", ()=>{
        it("should detect active trial period", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            const futureDate = new Date();
            futureDate.setDate(futureDate.getDate() + 7);
            (0, _react1.act)(()=>{
                result.current.trial = {
                    id: "trial-1",
                    user_id: mockUser.id,
                    trial_start: new Date().toISOString(),
                    trial_end: futureDate.toISOString(),
                    is_used: false,
                    created_at: new Date().toISOString()
                };
            });
            expect(result.current.isInTrial).toBe(true);
            expect(result.current.trialDaysRemaining).toBeGreaterThan(0);
            expect(result.current.subscriptionRequired).toBe(false);
        });
        it("should detect expired trial", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            const pastDate = new Date();
            pastDate.setDate(pastDate.getDate() - 1);
            (0, _react1.act)(()=>{
                result.current.trial = {
                    id: "trial-1",
                    user_id: mockUser.id,
                    trial_start: new Date().toISOString(),
                    trial_end: pastDate.toISOString(),
                    is_used: false,
                    created_at: new Date().toISOString()
                };
            });
            expect(result.current.isInTrial).toBe(false);
            expect(result.current.trialDaysRemaining).toBe(0);
            expect(result.current.subscriptionRequired).toBe(true);
        });
        it("should mark trial as used", async ()=>{
            const { supabase } = require("@/lib/supabase");
            supabase.from.mockReturnValue({
                update: jest.fn(()=>({
                        eq: jest.fn(()=>Promise.resolve({
                                error: null
                            }))
                    }))
            });
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            (0, _react1.act)(()=>{
                result.current.trial = {
                    id: "trial-1",
                    user_id: mockUser.id,
                    trial_start: new Date().toISOString(),
                    trial_end: new Date().toISOString(),
                    is_used: false,
                    created_at: new Date().toISOString()
                };
            });
            await (0, _react1.act)(async ()=>{
                await result.current.markTrialAsUsed();
            });
            expect(supabase.from).toHaveBeenCalledWith("subscription_trials");
        });
    });
    describe("Usage Tracking", ()=>{
        it("should track membership usage correctly", async ()=>{
            const { supabase } = require("@/lib/supabase");
            supabase.from.mockReturnValue({
                insert: jest.fn(()=>Promise.resolve({
                        error: null
                    }))
            });
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            (0, _react1.act)(()=>{
                result.current.subscription = _testutils.portugueseTestUtils.mockPremiumSubscription;
            });
            await (0, _react1.act)(async ()=>{
                await result.current.trackMembershipUsage("transport_discount", "executive_transport", 20, 15.50);
            });
            expect(supabase.from).toHaveBeenCalledWith("membership_usage");
        });
    });
    describe("Portuguese Context Integration", ()=>{
        it("should provide Portuguese error messages", async ()=>{
            const mockFetch = global.fetch;
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400
            });
            // Mock toast
            const { toast } = require("react-hot-toast");
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            // Set language to Portuguese
            const languageContext = require("@/context/LanguageContext");
            languageContext.language = "pt";
            await (0, _react1.act)(async ()=>{
                await result.current.createSubscription("community");
            });
            // Should show Portuguese error message
            expect(toast.error).toHaveBeenCalledWith(expect.stringContaining("Erro ao criar subscri\xe7\xe3o"));
        });
        it("should handle Portuguese subscription tiers", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            const portugueseTiers = [
                "community",
                "silver",
                "gold",
                "ambassador"
            ];
            portugueseTiers.forEach((tier)=>{
                (0, _react1.act)(()=>{
                    result.current.subscription = {
                        ..._testutils.portugueseTestUtils.mockPremiumSubscription,
                        tier,
                        status: "active",
                        current_period_end: "2025-01-01T00:00:00Z"
                    };
                });
                expect(result.current.membershipTier).toBe(tier);
                expect(result.current.hasActiveSubscription).toBe(true);
            });
        });
    });
    describe("Error Handling", ()=>{
        it("should handle network errors gracefully", async ()=>{
            const mockFetch = global.fetch;
            mockFetch.mockRejectedValueOnce(new Error("Network error"));
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            await (0, _react1.act)(async ()=>{
                const sessionId = await result.current.createSubscription("community");
                expect(sessionId).toBeNull();
            });
        });
        it("should handle Supabase errors", async ()=>{
            const { supabase } = require("@/lib/supabase");
            supabase.from.mockReturnValue({
                update: jest.fn(()=>({
                        eq: jest.fn(()=>Promise.resolve({
                                error: {
                                    message: "Database error"
                                }
                            }))
                    }))
            });
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            (0, _react1.act)(()=>{
                result.current.trial = {
                    id: "trial-1",
                    user_id: mockUser.id,
                    is_used: false
                };
            });
            await (0, _react1.act)(async ()=>{
                await result.current.markTrialAsUsed();
            });
            // Should not crash, error should be logged
            expect(console.error).toHaveBeenCalled();
        });
    });
    describe("Subscription Status Detection", ()=>{
        it("should correctly identify active subscription", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            const futureDate = new Date();
            futureDate.setFullYear(futureDate.getFullYear() + 1);
            (0, _react1.act)(()=>{
                result.current.subscription = {
                    ..._testutils.portugueseTestUtils.mockPremiumSubscription,
                    status: "active",
                    current_period_end: futureDate.toISOString()
                };
            });
            expect(result.current.hasActiveSubscription).toBe(true);
            expect(result.current.subscriptionRequired).toBe(false);
        });
        it("should correctly identify expired subscription", ()=>{
            const { result } = (0, _react1.renderHook)(()=>(0, _SubscriptionContext.useSubscription)(), {
                wrapper
            });
            const pastDate = new Date();
            pastDate.setFullYear(pastDate.getFullYear() - 1);
            (0, _react1.act)(()=>{
                result.current.subscription = {
                    ..._testutils.portugueseTestUtils.mockPremiumSubscription,
                    status: "active",
                    current_period_end: pastDate.toISOString()
                };
            });
            expect(result.current.hasActiveSubscription).toBe(false);
            expect(result.current.subscriptionRequired).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL0x1c29Ub3duL3dlYi1hcHAvX190ZXN0c19fL2NvbnRleHRzL1N1YnNjcmlwdGlvbkNvbnRleHQudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgcmVuZGVySG9vaywgYWN0IH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCdcbmltcG9ydCB7IFN1YnNjcmlwdGlvblByb3ZpZGVyLCB1c2VTdWJzY3JpcHRpb24gfSBmcm9tICdAL2NvbnRleHQvU3Vic2NyaXB0aW9uQ29udGV4dCdcbmltcG9ydCB7IExhbmd1YWdlUHJvdmlkZXIgfSBmcm9tICdAL2NvbnRleHQvTGFuZ3VhZ2VDb250ZXh0J1xuaW1wb3J0IHsgcG9ydHVndWVzZVRlc3RVdGlscyB9IGZyb20gJy4uL3V0aWxzL3Rlc3QtdXRpbHMnXG5cbi8vIE1vY2sgU3RyaXBlXG5qZXN0Lm1vY2soJ0BzdHJpcGUvc3RyaXBlLWpzJywgKCkgPT4gKHtcbiAgbG9hZFN0cmlwZTogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoe1xuICAgIHJlZGlyZWN0VG9DaGVja291dDogamVzdC5mbigpLFxuICB9KSksXG59KSlcblxuLy8gTW9jayBhdXRoIHNlcnZpY2Vcbmplc3QubW9jaygnQC9saWIvYXV0aCcsICgpID0+ICh7XG4gIGF1dGhTZXJ2aWNlOiB7XG4gICAgZ2V0Q3VycmVudFVzZXI6IGplc3QuZm4oKSxcbiAgICBpc0RlbW9Vc2VyOiBqZXN0LmZuKCgpID0+IGZhbHNlKSxcbiAgICBvbkF1dGhTdGF0ZUNoYW5nZTogamVzdC5mbigoKSA9PiBqZXN0LmZuKCkpLFxuICB9LFxufSkpXG5cbi8vIE1vY2sgU3VwYWJhc2Vcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZToge1xuICAgIGZyb206IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KSksXG4gICAgICAgIH0pKSxcbiAgICAgIH0pKSxcbiAgICAgIGluc2VydDogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KSksXG4gICAgICB1cGRhdGU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSkpLFxuICAgICAgfSkpLFxuICAgIH0pKSxcbiAgfSxcbn0pKVxuXG4vLyBNb2NrIGZldGNoIGZvciBBUEkgY2FsbHNcbmdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKVxuXG5kZXNjcmliZSgnU3Vic2NyaXB0aW9uQ29udGV4dCcsICgpID0+IHtcbiAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgaWQ6ICd0ZXN0LXVzZXInLFxuICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gIH1cblxuICBjb25zdCB3cmFwcGVyID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pID0+IChcbiAgICA8TGFuZ3VhZ2VQcm92aWRlcj5cbiAgICAgIDxTdWJzY3JpcHRpb25Qcm92aWRlcj57Y2hpbGRyZW59PC9TdWJzY3JpcHRpb25Qcm92aWRlcj5cbiAgICA8L0xhbmd1YWdlUHJvdmlkZXI+XG4gIClcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICAgIGNvbnN0IHsgYXV0aFNlcnZpY2UgfSA9IHJlcXVpcmUoJ0AvbGliL2F1dGgnKVxuICAgIGF1dGhTZXJ2aWNlLmdldEN1cnJlbnRVc2VyLm1vY2tSZXR1cm5WYWx1ZShtb2NrVXNlcilcbiAgICBhdXRoU2VydmljZS5pc0RlbW9Vc2VyLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSlcbiAgfSlcblxuICBkZXNjcmliZSgnSW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHdpdGggbG9hZGluZyBzdGF0ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN1YnNjcmlwdGlvbigpLCB7IHdyYXBwZXIgfSlcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN1YnNjcmlwdGlvbikudG9CZU51bGwoKVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc0FjdGl2ZVN1YnNjcmlwdGlvbikudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGVtbyB1c2VyIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgYXV0aFNlcnZpY2UgfSA9IHJlcXVpcmUoJ0AvbGliL2F1dGgnKVxuICAgICAgYXV0aFNlcnZpY2UuaXNEZW1vVXNlci5tb2NrUmV0dXJuVmFsdWUodHJ1ZSlcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3Vic2NyaXB0aW9uKCksIHsgd3JhcHBlciB9KVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3Vic2NyaXB0aW9uUmVxdWlyZWQpLnRvQmUoZmFsc2UpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnU3Vic2NyaXB0aW9uIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgc3Vic2NyaXB0aW9uIHdpdGggY29ycmVjdCB0aWVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ZldGNoID0gZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGZldGNoPlxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBzZXNzaW9uSWQ6ICd0ZXN0LXNlc3Npb24taWQnIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSlcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3Vic2NyaXB0aW9uKCksIHsgd3JhcHBlciB9KVxuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5jcmVhdGVTdWJzY3JpcHRpb24oJ2FtYmFzc2Fkb3InKVxuICAgICAgICBleHBlY3Qoc2Vzc2lvbklkKS50b0JlKCd0ZXN0LXNlc3Npb24taWQnKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvY3JlYXRlLXN1YnNjcmlwdGlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkOiBtb2NrVXNlci5pZCxcbiAgICAgICAgICB1c2VyRW1haWw6IG1vY2tVc2VyLmVtYWlsLFxuICAgICAgICAgIHVzZXJOYW1lOiBtb2NrVXNlci5uYW1lLFxuICAgICAgICAgIHRpZXI6ICdhbWJhc3NhZG9yJyxcbiAgICAgICAgfSksXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzdWJzY3JpcHRpb24gY3JlYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tGZXRjaCA9IGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBmZXRjaD5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgfSBhcyBSZXNwb25zZSlcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3Vic2NyaXB0aW9uKCksIHsgd3JhcHBlciB9KVxuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5jcmVhdGVTdWJzY3JpcHRpb24oJ2NvbW11bml0eScpXG4gICAgICAgIGV4cGVjdChzZXNzaW9uSWQpLnRvQmVOdWxsKClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgdXBncmFkZSBzdWJzY3JpcHRpb24gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ZldGNoID0gZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGZldGNoPlxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoe30pLFxuICAgICAgfSBhcyBSZXNwb25zZSlcblxuICAgICAgLy8gU2V0IHVwIGV4aXN0aW5nIHN1YnNjcmlwdGlvblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3Vic2NyaXB0aW9uKCksIHsgd3JhcHBlciB9KVxuICAgICAgXG4gICAgICAvLyBNb2NrIGV4aXN0aW5nIHN1YnNjcmlwdGlvblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgKHJlc3VsdC5jdXJyZW50IGFzIGFueSkuc3Vic2NyaXB0aW9uID0gcG9ydHVndWVzZVRlc3RVdGlscy5tb2NrUHJlbWl1bVN1YnNjcmlwdGlvblxuICAgICAgfSlcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LnVwZ3JhZGVTdWJzY3JpcHRpb24oJ2FtYmFzc2Fkb3InKVxuICAgICAgICBleHBlY3Qoc3VjY2VzcykudG9CZSh0cnVlKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvdXBncmFkZS1zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsIC8vIHNpbmNlIHdlIG1vY2tlZCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgbmV3VGllcjogJ2FtYmFzc2Fkb3InLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgY2FuY2VsIHN1YnNjcmlwdGlvbiBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRmV0Y2ggPSBnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZmV0Y2g+XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7fSksXG4gICAgICB9IGFzIFJlc3BvbnNlKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIC8vIE1vY2sgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAocmVzdWx0LmN1cnJlbnQgYXMgYW55KS5zdWJzY3JpcHRpb24gPSBwb3J0dWd1ZXNlVGVzdFV0aWxzLm1vY2tQcmVtaXVtU3Vic2NyaXB0aW9uXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQuY2FuY2VsU3Vic2NyaXB0aW9uKClcbiAgICAgICAgZXhwZWN0KHN1Y2Nlc3MpLnRvQmUodHJ1ZSlcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2NhbmNlbC1zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsIC8vIHNpbmNlIHdlIG1vY2tlZCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pLFxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNZW1iZXJzaGlwIFRpZXJzIGFuZCBEaXNjb3VudHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgY29ycmVjdCBzZXJ2aWNlIGRpc2NvdW50IGZvciBlYWNoIHRpZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIC8vIFRlc3QgZGlmZmVyZW50IHRpZXJzXG4gICAgICBjb25zdCB0aWVycyA9IFtcbiAgICAgICAgeyB0aWVyOiAnY29tbXVuaXR5JywgZXhwZWN0ZWREaXNjb3VudDogMTAgfSxcbiAgICAgICAgeyB0aWVyOiAnc2lsdmVyJywgZXhwZWN0ZWREaXNjb3VudDogMTUgfSxcbiAgICAgICAgeyB0aWVyOiAnZ29sZCcsIGV4cGVjdGVkRGlzY291bnQ6IDIwIH0sXG4gICAgICAgIHsgdGllcjogJ2FtYmFzc2Fkb3InLCBleHBlY3RlZERpc2NvdW50OiAyNSB9LFxuICAgICAgXVxuXG4gICAgICB0aWVycy5mb3JFYWNoKCh7IHRpZXIsIGV4cGVjdGVkRGlzY291bnQgfSkgPT4ge1xuICAgICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAgIChyZXN1bHQuY3VycmVudCBhcyBhbnkpLnN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnBvcnR1Z3Vlc2VUZXN0VXRpbHMubW9ja1ByZW1pdW1TdWJzY3JpcHRpb24sXG4gICAgICAgICAgICB0aWVyLFxuICAgICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlcnZpY2VEaXNjb3VudCkudG9CZShleHBlY3RlZERpc2NvdW50KVxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubWVtYmVyc2hpcFRpZXIpLnRvQmUodGllcilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG5vIGRpc2NvdW50IGZvciBpbmFjdGl2ZSBzdWJzY3JpcHRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZXJ2aWNlRGlzY291bnQpLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5tZW1iZXJzaGlwVGllcikudG9CZSgnbm9uZScpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVHJpYWwgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRldGVjdCBhY3RpdmUgdHJpYWwgcGVyaW9kJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3Vic2NyaXB0aW9uKCksIHsgd3JhcHBlciB9KVxuICAgICAgXG4gICAgICBjb25zdCBmdXR1cmVEYXRlID0gbmV3IERhdGUoKVxuICAgICAgZnV0dXJlRGF0ZS5zZXREYXRlKGZ1dHVyZURhdGUuZ2V0RGF0ZSgpICsgNylcbiAgICAgIFxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgKHJlc3VsdC5jdXJyZW50IGFzIGFueSkudHJpYWwgPSB7XG4gICAgICAgICAgaWQ6ICd0cmlhbC0xJyxcbiAgICAgICAgICB1c2VyX2lkOiBtb2NrVXNlci5pZCxcbiAgICAgICAgICB0cmlhbF9zdGFydDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHRyaWFsX2VuZDogZnV0dXJlRGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGlzX3VzZWQ6IGZhbHNlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzSW5UcmlhbCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnRyaWFsRGF5c1JlbWFpbmluZykudG9CZUdyZWF0ZXJUaGFuKDApXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3Vic2NyaXB0aW9uUmVxdWlyZWQpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGV4cGlyZWQgdHJpYWwnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IHBhc3REYXRlID0gbmV3IERhdGUoKVxuICAgICAgcGFzdERhdGUuc2V0RGF0ZShwYXN0RGF0ZS5nZXREYXRlKCkgLSAxKVxuICAgICAgXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAocmVzdWx0LmN1cnJlbnQgYXMgYW55KS50cmlhbCA9IHtcbiAgICAgICAgICBpZDogJ3RyaWFsLTEnLFxuICAgICAgICAgIHVzZXJfaWQ6IG1vY2tVc2VyLmlkLFxuICAgICAgICAgIHRyaWFsX3N0YXJ0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdHJpYWxfZW5kOiBwYXN0RGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGlzX3VzZWQ6IGZhbHNlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzSW5UcmlhbCkudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC50cmlhbERheXNSZW1haW5pbmcpLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zdWJzY3JpcHRpb25SZXF1aXJlZCkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIG1hcmsgdHJpYWwgYXMgdXNlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJylcbiAgICAgIHN1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZXJyb3I6IG51bGwgfSkpLFxuICAgICAgICB9KSksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIChyZXN1bHQuY3VycmVudCBhcyBhbnkpLnRyaWFsID0ge1xuICAgICAgICAgIGlkOiAndHJpYWwtMScsXG4gICAgICAgICAgdXNlcl9pZDogbW9ja1VzZXIuaWQsXG4gICAgICAgICAgdHJpYWxfc3RhcnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB0cmlhbF9lbmQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBpc191c2VkOiBmYWxzZSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50Lm1hcmtUcmlhbEFzVXNlZCgpXG4gICAgICB9KVxuXG4gICAgICBleHBlY3Qoc3VwYWJhc2UuZnJvbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N1YnNjcmlwdGlvbl90cmlhbHMnKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1VzYWdlIFRyYWNraW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdHJhY2sgbWVtYmVyc2hpcCB1c2FnZSBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHN1cGFiYXNlIH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpXG4gICAgICBzdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGluc2VydDogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBlcnJvcjogbnVsbCB9KSksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIChyZXN1bHQuY3VycmVudCBhcyBhbnkpLnN1YnNjcmlwdGlvbiA9IHBvcnR1Z3Vlc2VUZXN0VXRpbHMubW9ja1ByZW1pdW1TdWJzY3JpcHRpb25cbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnRyYWNrTWVtYmVyc2hpcFVzYWdlKFxuICAgICAgICAgICd0cmFuc3BvcnRfZGlzY291bnQnLFxuICAgICAgICAgICdleGVjdXRpdmVfdHJhbnNwb3J0JyxcbiAgICAgICAgICAyMCxcbiAgICAgICAgICAxNS41MFxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICBleHBlY3Qoc3VwYWJhc2UuZnJvbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ21lbWJlcnNoaXBfdXNhZ2UnKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1BvcnR1Z3Vlc2UgQ29udGV4dCBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb3ZpZGUgUG9ydHVndWVzZSBlcnJvciBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tGZXRjaCA9IGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBmZXRjaD5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgfSBhcyBSZXNwb25zZSlcblxuICAgICAgLy8gTW9jayB0b2FzdFxuICAgICAgY29uc3QgeyB0b2FzdCB9ID0gcmVxdWlyZSgncmVhY3QtaG90LXRvYXN0JylcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3Vic2NyaXB0aW9uKCksIHsgd3JhcHBlciB9KVxuICAgICAgXG4gICAgICAvLyBTZXQgbGFuZ3VhZ2UgdG8gUG9ydHVndWVzZVxuICAgICAgY29uc3QgbGFuZ3VhZ2VDb250ZXh0ID0gcmVxdWlyZSgnQC9jb250ZXh0L0xhbmd1YWdlQ29udGV4dCcpXG4gICAgICBsYW5ndWFnZUNvbnRleHQubGFuZ3VhZ2UgPSAncHQnXG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmNyZWF0ZVN1YnNjcmlwdGlvbignY29tbXVuaXR5JylcbiAgICAgIH0pXG5cbiAgICAgIC8vIFNob3VsZCBzaG93IFBvcnR1Z3Vlc2UgZXJyb3IgbWVzc2FnZVxuICAgICAgZXhwZWN0KHRvYXN0LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0Vycm8gYW8gY3JpYXIgc3Vic2NyacOnw6NvJylcbiAgICAgIClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgUG9ydHVndWVzZSBzdWJzY3JpcHRpb24gdGllcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IHBvcnR1Z3Vlc2VUaWVycyA9IFsnY29tbXVuaXR5JywgJ3NpbHZlcicsICdnb2xkJywgJ2FtYmFzc2Fkb3InXSBhcyBjb25zdFxuICAgICAgXG4gICAgICBwb3J0dWd1ZXNlVGllcnMuZm9yRWFjaCh0aWVyID0+IHtcbiAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICAocmVzdWx0LmN1cnJlbnQgYXMgYW55KS5zdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAuLi5wb3J0dWd1ZXNlVGVzdFV0aWxzLm1vY2tQcmVtaXVtU3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgdGllcixcbiAgICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5tZW1iZXJzaGlwVGllcikudG9CZSh0aWVyKVxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaGFzQWN0aXZlU3Vic2NyaXB0aW9uKS50b0JlKHRydWUpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRmV0Y2ggPSBnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZmV0Y2g+XG4gICAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LmNyZWF0ZVN1YnNjcmlwdGlvbignY29tbXVuaXR5JylcbiAgICAgICAgZXhwZWN0KHNlc3Npb25JZCkudG9CZU51bGwoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgU3VwYWJhc2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBzdXBhYmFzZSB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKVxuICAgICAgc3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBlcTogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgZXJyb3InIH0gfSkpLFxuICAgICAgICB9KSksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdWJzY3JpcHRpb24oKSwgeyB3cmFwcGVyIH0pXG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIChyZXN1bHQuY3VycmVudCBhcyBhbnkpLnRyaWFsID0ge1xuICAgICAgICAgIGlkOiAndHJpYWwtMScsXG4gICAgICAgICAgdXNlcl9pZDogbW9ja1VzZXIuaWQsXG4gICAgICAgICAgaXNfdXNlZDogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50Lm1hcmtUcmlhbEFzVXNlZCgpXG4gICAgICB9KVxuXG4gICAgICAvLyBTaG91bGQgbm90IGNyYXNoLCBlcnJvciBzaG91bGQgYmUgbG9nZ2VkXG4gICAgICBleHBlY3QoY29uc29sZS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnU3Vic2NyaXB0aW9uIFN0YXR1cyBEZXRlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb3JyZWN0bHkgaWRlbnRpZnkgYWN0aXZlIHN1YnNjcmlwdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN1YnNjcmlwdGlvbigpLCB7IHdyYXBwZXIgfSlcbiAgICAgIFxuICAgICAgY29uc3QgZnV0dXJlRGF0ZSA9IG5ldyBEYXRlKClcbiAgICAgIGZ1dHVyZURhdGUuc2V0RnVsbFllYXIoZnV0dXJlRGF0ZS5nZXRGdWxsWWVhcigpICsgMSlcbiAgICAgIFxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgKHJlc3VsdC5jdXJyZW50IGFzIGFueSkuc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgIC4uLnBvcnR1Z3Vlc2VUZXN0VXRpbHMubW9ja1ByZW1pdW1TdWJzY3JpcHRpb24sXG4gICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IGZ1dHVyZURhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc0FjdGl2ZVN1YnNjcmlwdGlvbikudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN1YnNjcmlwdGlvblJlcXVpcmVkKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGNvcnJlY3RseSBpZGVudGlmeSBleHBpcmVkIHN1YnNjcmlwdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN1YnNjcmlwdGlvbigpLCB7IHdyYXBwZXIgfSlcbiAgICAgIFxuICAgICAgY29uc3QgcGFzdERhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICBwYXN0RGF0ZS5zZXRGdWxsWWVhcihwYXN0RGF0ZS5nZXRGdWxsWWVhcigpIC0gMSlcbiAgICAgIFxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgKHJlc3VsdC5jdXJyZW50IGFzIGFueSkuc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgIC4uLnBvcnR1Z3Vlc2VUZXN0VXRpbHMubW9ja1ByZW1pdW1TdWJzY3JpcHRpb24sXG4gICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IHBhc3REYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNBY3RpdmVTdWJzY3JpcHRpb24pLnRvQmUoZmFsc2UpXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3Vic2NyaXB0aW9uUmVxdWlyZWQpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImxvYWRTdHJpcGUiLCJmbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVkaXJlY3RUb0NoZWNrb3V0IiwiYXV0aFNlcnZpY2UiLCJnZXRDdXJyZW50VXNlciIsImlzRGVtb1VzZXIiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsInN1cGFiYXNlIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiZGF0YSIsImVycm9yIiwiaW5zZXJ0IiwidXBkYXRlIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsIm1vY2tVc2VyIiwiaWQiLCJlbWFpbCIsIm5hbWUiLCJ3cmFwcGVyIiwiY2hpbGRyZW4iLCJMYW5ndWFnZVByb3ZpZGVyIiwiU3Vic2NyaXB0aW9uUHJvdmlkZXIiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInJlcXVpcmUiLCJtb2NrUmV0dXJuVmFsdWUiLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VTdWJzY3JpcHRpb24iLCJleHBlY3QiLCJjdXJyZW50IiwiaXNMb2FkaW5nIiwidG9CZSIsInN1YnNjcmlwdGlvbiIsInRvQmVOdWxsIiwiaGFzQWN0aXZlU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uUmVxdWlyZWQiLCJtb2NrRmV0Y2giLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzZXNzaW9uSWQiLCJhY3QiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVzZXJJZCIsInVzZXJFbWFpbCIsInVzZXJOYW1lIiwidGllciIsInN0YXR1cyIsInBvcnR1Z3Vlc2VUZXN0VXRpbHMiLCJtb2NrUHJlbWl1bVN1YnNjcmlwdGlvbiIsInN1Y2Nlc3MiLCJ1cGdyYWRlU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uSWQiLCJ1bmRlZmluZWQiLCJuZXdUaWVyIiwiY2FuY2VsU3Vic2NyaXB0aW9uIiwidGllcnMiLCJleHBlY3RlZERpc2NvdW50IiwiZm9yRWFjaCIsImN1cnJlbnRfcGVyaW9kX2VuZCIsInNlcnZpY2VEaXNjb3VudCIsIm1lbWJlcnNoaXBUaWVyIiwiZnV0dXJlRGF0ZSIsIkRhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInRyaWFsIiwidXNlcl9pZCIsInRyaWFsX3N0YXJ0IiwidG9JU09TdHJpbmciLCJ0cmlhbF9lbmQiLCJpc191c2VkIiwiY3JlYXRlZF9hdCIsImlzSW5UcmlhbCIsInRyaWFsRGF5c1JlbWFpbmluZyIsInRvQmVHcmVhdGVyVGhhbiIsInBhc3REYXRlIiwibWFya1RyaWFsQXNVc2VkIiwidHJhY2tNZW1iZXJzaGlwVXNhZ2UiLCJ0b2FzdCIsImxhbmd1YWdlQ29udGV4dCIsImxhbmd1YWdlIiwic3RyaW5nQ29udGFpbmluZyIsInBvcnR1Z3Vlc2VUaWVycyIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwic2V0RnVsbFllYXIiLCJnZXRGdWxsWWVhciJdLCJtYXBwaW5ncyI6IjtBQU1BLGNBQWM7QUFDZEEsS0FBS0MsSUFBSSxDQUFDLHFCQUFxQixJQUFPLENBQUE7UUFDcENDLFlBQVlGLEtBQUtHLEVBQUUsQ0FBQyxJQUFNQyxRQUFRQyxPQUFPLENBQUM7Z0JBQ3hDQyxvQkFBb0JOLEtBQUtHLEVBQUU7WUFDN0I7SUFDRixDQUFBO0FBRUEsb0JBQW9CO0FBQ3BCSCxLQUFLQyxJQUFJLENBQUMsY0FBYyxJQUFPLENBQUE7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