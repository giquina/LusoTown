{"version":3,"sources":["/workspaces/LusoTown/web-app/src/context/SubscriptionContext.tsx"],"sourcesContent":["'use client'\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode } from 'react'\nimport { loadStripe, Stripe } from '@stripe/stripe-js'\nimport { useLanguage } from './LanguageContext'\nimport { authService } from '@/lib/auth'\nimport { supabase } from '@/lib/supabase'\nimport toast from 'react-hot-toast'\nimport { ROUTES } from '@/config/routes'\nimport logger from '@/utils/logger'\n\n// Initialize Stripe - with fallback for development\nconst stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || 'pk_test_placeholder')\n\nexport interface Subscription {\n  id: string\n  user_id: string\n  stripe_subscription_id?: string\n  stripe_customer_id?: string\n  status: 'active' | 'inactive' | 'cancelled' | 'past_due' | 'trialing'\n  plan_type: 'monthly' | 'yearly'\n  tier: 'free' | 'community' | 'ambassador' | 'familia'\n  current_period_start?: string\n  current_period_end?: string\n  trial_end?: string\n  amount: number\n  currency: string\n  student_verified?: boolean\n  corporate_account_id?: string\n  created_at: string\n  updated_at: string\n}\n\nexport interface SubscriptionTrial {\n  id: string\n  user_id: string\n  trial_start: string\n  trial_end: string\n  is_used: boolean\n  created_at: string\n}\n\nexport interface SubscriptionUsageLimits {\n  dailyMatches: number\n  monthlyMessages: number\n  premiumEvents: number\n  livestreamHours: number\n  hasUnlimitedAccess: boolean\n}\n\nexport interface SubscriptionUsage {\n  dailyMatchesUsed: number\n  monthlyMessagesUsed: number\n  premiumEventsUsed: number\n  livestreamHoursUsed: number\n  lastResetDate: string\n}\n\ninterface SubscriptionContextType {\n  subscription: Subscription | null\n  trial: SubscriptionTrial | null\n  usage: SubscriptionUsage | null\n  isLoading: boolean\n  hasActiveSubscription: boolean\n  isInTrial: boolean\n  trialDaysRemaining: number\n  subscriptionRequired: boolean\n  stripe: Stripe | null\n  membershipTier: 'none' | 'free' | 'community' | 'ambassador' | 'familia'\n  serviceDiscount: number\n  usageLimits: SubscriptionUsageLimits\n  \n  // Feature access\n  canSendMessage: () => boolean\n  canCreateMatch: () => boolean\n  canAccessPremiumEvent: () => boolean\n  canAccessLivestream: () => boolean\n  getRemainingMatches: () => number\n  getRemainingMessages: () => number\n  \n  // Actions\n  checkSubscriptionStatus: () => Promise<void>\n  createSubscription: (tier?: 'free' | 'community' | 'ambassador' | 'familia', planType?: 'monthly' | 'yearly') => Promise<string | null>\n  upgradeSubscription: (newTier: 'free' | 'community' | 'ambassador' | 'familia') => Promise<boolean>\n  cancelSubscription: () => Promise<boolean>\n  redirectToSubscription: () => void\n  markTrialAsUsed: () => Promise<void>\n  trackMembershipUsage: (benefitType: string, serviceType: string, discountApplied?: number, amountSaved?: number) => Promise<void>\n  trackFeatureUsage: (feature: 'match' | 'message' | 'premium_event' | 'livestream') => Promise<boolean>\n  validateStudentStatus: (studentEmail: string, universityId: string) => Promise<boolean>\n}\n\nconst SubscriptionContext = createContext<SubscriptionContextType | undefined>(undefined)\n\ninterface SubscriptionProviderProps {\n  children: ReactNode\n}\n\nexport function SubscriptionProvider({ children }: SubscriptionProviderProps) {\n  const { language, t } = useLanguage()\n  const [subscription, setSubscription] = useState<Subscription | null>(null)\n  const [trial, setTrial] = useState<SubscriptionTrial | null>(null)\n  const [usage, setUsage] = useState<SubscriptionUsage | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n  const [stripe, setStripe] = useState<Stripe | null>(null)\n\n  // Initialize Stripe\n  useEffect(() => {\n    const initializeStripe = async () => {\n      const stripeInstance = await stripePromise\n      setStripe(stripeInstance)\n    }\n    initializeStripe()\n  }, [])\n\n  // Load subscription status when user changes\n  useEffect(() => {\n    const checkUserSubscription = async () => {\n      const user = authService.getCurrentUser()\n      if (user && !authService.isDemoUser()) {\n        await checkSubscriptionStatus()\n      } else {\n        setSubscription(null)\n        setTrial(null)\n        setIsLoading(false)\n      }\n    }\n\n    checkUserSubscription()\n\n    // Listen for auth state changes\n    const unsubscribe = authService.onAuthStateChange(checkUserSubscription)\n    return unsubscribe\n  }, [])\n\n  const checkSubscriptionStatus = async () => {\n    setIsLoading(true)\n    try {\n      const user = authService.getCurrentUser()\n      if (!user || authService.isDemoUser()) {\n        setSubscription(null)\n        setTrial(null)\n        return\n      }\n\n      // Check for active subscription\n      const { data: subscriptionData, error: subError } = await supabase\n        .from('subscriptions')\n        .select('*')\n        .eq('user_id', user.id)\n        .eq('status', 'active')\n        .single()\n\n      if (subError && subError.code !== 'PGRST116') {\n        logger.error('Error fetching subscription:', subError)\n      } else if (subscriptionData) {\n        setSubscription(subscriptionData)\n      }\n\n      // Check for trial status\n      const { data: trialData, error: trialError } = await supabase\n        .from('subscription_trials')\n        .select('*')\n        .eq('user_id', user.id)\n        .single()\n\n      if (trialError && trialError.code !== 'PGRST116') {\n        logger.error('Error fetching trial:', trialError)\n      } else if (trialData) {\n        setTrial(trialData)\n      }\n    } catch (error) {\n      logger.error('Error checking subscription status:', error)\n    } finally {\n      setIsLoading(false)\n    }\n  }\n\n  const createSubscription = async (\n    tier: 'free' | 'community' | 'ambassador' | 'familia' = 'community',\n    planType: 'monthly' | 'yearly' = 'monthly'\n  ): Promise<string | null> => {\n    try {\n      const user = authService.getCurrentUser()\n      if (!user || authService.isDemoUser()) {\n        throw new Error('User must be logged in to create subscription')\n      }\n\n      // Call your backend API to create Stripe checkout session\n      const response = await fetch('/api/create-subscription', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          userId: user.id,\n          userEmail: user.email,\n          userName: user.name,\n          tier: tier,\n          planType: planType,\n        }),\n      })\n\n      if (!response.ok) {\n        throw new Error('Failed to create subscription')\n      }\n\n      const { sessionId } = await response.json()\n      \n      if (!stripe) {\n        throw new Error('Stripe not initialized')\n      }\n\n      // Redirect to Stripe Checkout\n      const { error } = await stripe.redirectToCheckout({\n        sessionId,\n      })\n\n      if (error) {\n        logger.error('Stripe checkout error:', error)\n        toast.error(\n          language === 'pt' \n            ? 'Erro ao processar pagamento. Tente novamente.' \n            : 'Payment processing error. Please try again.'\n        )\n        return null\n      }\n\n      return sessionId\n    } catch (error) {\n      logger.error('Error creating subscription:', error)\n      toast.error(\n        language === 'pt' \n          ? 'Erro ao criar subscrição. Tente novamente.' \n          : 'Error creating subscription. Please try again.'\n      )\n      return null\n    }\n  }\n\n  const cancelSubscription = async (): Promise<boolean> => {\n    try {\n      const user = authService.getCurrentUser()\n      if (!user || !subscription) {\n        return false\n      }\n\n      const response = await fetch('/api/cancel-subscription', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          subscriptionId: subscription.stripe_subscription_id,\n        }),\n      })\n\n      if (!response.ok) {\n        throw new Error('Failed to cancel subscription')\n      }\n\n      // Refresh subscription status\n      await checkSubscriptionStatus()\n      \n      toast.success(\n        language === 'pt' \n          ? 'Subscrição cancelada com sucesso' \n          : 'Subscription cancelled successfully'\n      )\n      \n      return true\n    } catch (error) {\n      logger.error('Error cancelling subscription:', error)\n      toast.error(\n        language === 'pt' \n          ? 'Erro ao cancelar subscrição' \n          : 'Error cancelling subscription'\n      )\n      return false\n    }\n  }\n\n  const redirectToSubscription = () => {\n  window.location.href = ROUTES.subscription\n  }\n\n  const upgradeSubscription = async (newTier: 'free' | 'community' | 'ambassador'): Promise<boolean> => {\n    try {\n      const user = authService.getCurrentUser()\n      if (!user || !subscription) {\n        return false\n      }\n\n      const response = await fetch('/api/upgrade-subscription', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          subscriptionId: subscription.stripe_subscription_id,\n          newTier: newTier,\n        }),\n      })\n\n      if (!response.ok) {\n        throw new Error('Failed to upgrade subscription')\n      }\n\n      // Refresh subscription status\n      await checkSubscriptionStatus()\n      \n      toast.success(\n        language === 'pt' \n          ? 'Subscrição atualizada com sucesso' \n          : 'Subscription upgraded successfully'\n      )\n      \n      return true\n    } catch (error) {\n      logger.error('Error upgrading subscription:', error)\n      toast.error(\n        language === 'pt' \n          ? 'Erro ao atualizar subscrição' \n          : 'Error upgrading subscription'\n      )\n      return false\n    }\n  }\n\n  const markTrialAsUsed = async () => {\n    try {\n      const user = authService.getCurrentUser()\n      if (!user || !trial) return\n\n      const { error } = await supabase\n        .from('subscription_trials')\n        .update({ is_used: true })\n        .eq('user_id', user.id)\n\n      if (error) {\n        logger.error('Error marking trial as used:', error)\n      } else {\n        setTrial(prev => prev ? { ...prev, is_used: true } : null)\n      }\n    } catch (error) {\n      logger.error('Error marking trial as used:', error)\n    }\n  }\n\n  const trackMembershipUsage = async (\n    benefitType: string, \n    serviceType: string, \n    discountApplied: number = 0, \n    amountSaved: number = 0\n  ) => {\n    try {\n      const user = authService.getCurrentUser()\n      if (!user || !subscription) return\n\n      const { error } = await supabase\n        .from('membership_usage')\n        .insert({\n          user_id: user.id,\n          subscription_id: subscription.id,\n          benefit_type: benefitType,\n          service_type: serviceType,\n          discount_applied: discountApplied,\n          amount_saved: amountSaved,\n        })\n\n      if (error) {\n        logger.error('Error tracking membership usage:', error)\n      }\n    } catch (error) {\n      logger.error('Error tracking membership usage:', error)\n    }\n  }\n\n  const trackFeatureUsage = async (feature: 'match' | 'message' | 'premium_event' | 'livestream'): Promise<boolean> => {\n    try {\n      const user = authService.getCurrentUser()\n      if (!user) return false\n\n      // Check current usage limits\n      if (!canUseFeature(feature)) {\n        return false\n      }\n\n      // Update usage counts\n      const today = new Date().toISOString().split('T')[0]\n      const currentMonth = new Date().toISOString().substring(0, 7)\n      \n      // Start from a strongly-typed baseline and then copy forward allowed counters\n      let updatedUsage: SubscriptionUsage = {\n        dailyMatchesUsed: 0,\n        monthlyMessagesUsed:\n          usage?.lastResetDate?.substring(0, 7) === currentMonth ? usage!.monthlyMessagesUsed : 0,\n        premiumEventsUsed: 0,\n        livestreamHoursUsed: 0,\n        lastResetDate: today,\n      }\n\n      // If same day, carry forward today's counters\n      if (usage && usage.lastResetDate === today) {\n        updatedUsage.dailyMatchesUsed = usage.dailyMatchesUsed\n        updatedUsage.premiumEventsUsed = usage.premiumEventsUsed\n        updatedUsage.livestreamHoursUsed = usage.livestreamHoursUsed\n      }\n\n      // Increment the specific counter\n      switch (feature) {\n        case 'match':\n          updatedUsage.dailyMatchesUsed++\n          break\n        case 'message':\n          updatedUsage.monthlyMessagesUsed++\n          break\n        case 'premium_event':\n          updatedUsage.premiumEventsUsed++\n          break\n        case 'livestream':\n          updatedUsage.livestreamHoursUsed++\n          break\n      }\n\n      // Save to database\n      const { error } = await supabase\n        .from('subscription_usage')\n        .upsert({\n          user_id: user.id,\n          ...updatedUsage\n        })\n\n      if (error) {\n        logger.error('Error tracking feature usage:', error)\n        return false\n      }\n\n  setUsage(updatedUsage)\n      return true\n    } catch (error) {\n      logger.error('Error tracking feature usage:', error)\n      return false\n    }\n  }\n\n  const validateStudentStatus = async (studentEmail: string, universityId: string): Promise<boolean> => {\n    try {\n      const response = await fetch('/api/validate-student', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          email: studentEmail,\n          universityId: universityId,\n        }),\n      })\n\n      if (!response.ok) {\n        return false\n      }\n\n      const { isValid } = await response.json()\n      return isValid\n    } catch (error) {\n      logger.error('Error validating student status:', error)\n      return false\n    }\n  }\n\n  // Helper function to check feature usage\n  const canUseFeature = (feature: 'match' | 'message' | 'premium_event' | 'livestream'): boolean => {\n    if (usageLimits.hasUnlimitedAccess) return true\n    if (!usage) return true // First time usage\n\n    const today = new Date().toISOString().split('T')[0]\n    const currentMonth = new Date().toISOString().substring(0, 7)\n    \n    // Reset counters if needed\n    const dailyReset = usage.lastResetDate !== today\n    const monthlyReset = usage.lastResetDate.substring(0, 7) !== currentMonth\n\n    switch (feature) {\n      case 'match':\n        const dailyMatches = dailyReset ? 0 : usage.dailyMatchesUsed\n        return dailyMatches < usageLimits.dailyMatches\n      case 'message':\n        const monthlyMessages = monthlyReset ? 0 : usage.monthlyMessagesUsed\n        return monthlyMessages < usageLimits.monthlyMessages\n      case 'premium_event':\n        return usage.premiumEventsUsed < usageLimits.premiumEvents\n      case 'livestream':\n        return usage.livestreamHoursUsed < usageLimits.livestreamHours\n      default:\n        return false\n    }\n  }\n\n  // Computed values\n  const hasActiveSubscription = Boolean(\n    subscription && \n    subscription.status === 'active' && \n    subscription.current_period_end && \n    new Date(subscription.current_period_end) > new Date()\n  )\n\n  const isInTrial = Boolean(\n    trial && \n    !trial.is_used && \n    new Date(trial.trial_end) > new Date()\n  )\n\n  const trialDaysRemaining = trial && !trial.is_used ? \n    Math.max(0, Math.ceil((new Date(trial.trial_end).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))) : \n    0\n\n  // Subscription is required for all users except demo users\n  const subscriptionRequired = !authService.isDemoUser() && !hasActiveSubscription && !isInTrial\n\n  // Get current membership tier\n  const membershipTier: 'none' | 'free' | 'community' | 'ambassador' = \n    hasActiveSubscription && subscription?.tier ? subscription.tier : 'none'\n\n  // Normalize to an effective tier for limits/discounts\n  const effectiveTier: 'free' | 'community' | 'ambassador' | 'familia' = membershipTier === 'none' ? 'free' : membershipTier\n\n  // Calculate service discount based on tier - Portuguese-speaking community optimized\n  const serviceDiscount = (() => {\n    switch (effectiveTier) {\n      case 'community': return 10 // 10% member discount\n      case 'ambassador': return 20 // 20% ambassador discount  \n      case 'familia': return 15 // 15% family discount\n      default: return 0\n    }\n  })()\n\n  // Usage limits based on tier - Optimized for Portuguese-speaking community conversion\n  const usageLimits: SubscriptionUsageLimits = (() => {\n    switch (effectiveTier) {\n      case 'free':\n        return {\n          dailyMatches: 2, // Strategic limitation encouraging upgrade\n          monthlyMessages: 3, // Strategic limitation encouraging upgrade\n          premiumEvents: 0,\n          livestreamHours: 0,\n          hasUnlimitedAccess: false\n        }\n      case 'community':\n        return {\n          dailyMatches: -1, // unlimited matches\n          monthlyMessages: -1, // unlimited messaging\n          premiumEvents: -1, // unlimited community events (not premium events)\n          livestreamHours: 0, // no streaming access for community tier\n          hasUnlimitedAccess: false\n        }\n      case 'ambassador':\n        return {\n          dailyMatches: -1, // unlimited\n          monthlyMessages: -1, // unlimited\n          premiumEvents: -1, // unlimited including premium events\n          livestreamHours: 5, // 5 hours per month as stated in benefits\n          hasUnlimitedAccess: false // Limited streaming hours, not unlimited\n        }\n      case 'familia':\n        return {\n          dailyMatches: -1, // unlimited for all family members\n          monthlyMessages: -1, // unlimited for all family members\n          premiumEvents: -1, // unlimited including premium events\n          livestreamHours: 3, // 3 hours per month for family plan\n          hasUnlimitedAccess: false // Family-appropriate limitations\n        }\n      default:\n        return {\n          dailyMatches: 2,\n          monthlyMessages: 3,\n          premiumEvents: 0,\n          livestreamHours: 0,\n          hasUnlimitedAccess: false\n        }\n    }\n  })()\n\n  // Feature access functions\n  const canSendMessage = (): boolean => {\n    return canUseFeature('message')\n  }\n\n  const canCreateMatch = (): boolean => {\n    return canUseFeature('match')\n  }\n\n  const canAccessPremiumEvent = (): boolean => {\n    return canUseFeature('premium_event')\n  }\n\n  const canAccessLivestream = (): boolean => {\n    return canUseFeature('livestream')\n  }\n\n  const getRemainingMatches = (): number => {\n    if (usageLimits.hasUnlimitedAccess || usageLimits.dailyMatches === -1) return -1\n    \n    const today = new Date().toISOString().split('T')[0]\n    const dailyUsed = usage?.lastResetDate === today ? usage.dailyMatchesUsed : 0\n    return Math.max(0, usageLimits.dailyMatches - dailyUsed)\n  }\n\n  const getRemainingMessages = (): number => {\n    if (usageLimits.hasUnlimitedAccess || usageLimits.monthlyMessages === -1) return -1\n    \n    const currentMonth = new Date().toISOString().substring(0, 7)\n    const monthlyUsed = usage?.lastResetDate?.substring(0, 7) === currentMonth ? usage.monthlyMessagesUsed : 0\n    return Math.max(0, usageLimits.monthlyMessages - monthlyUsed)\n  }\n\n  const value: SubscriptionContextType = {\n    subscription,\n    trial,\n    usage,\n    isLoading,\n    hasActiveSubscription,\n    isInTrial,\n    trialDaysRemaining,\n    subscriptionRequired,\n    stripe,\n    membershipTier,\n    serviceDiscount,\n    usageLimits,\n    canSendMessage,\n    canCreateMatch,\n    canAccessPremiumEvent,\n    canAccessLivestream,\n    getRemainingMatches,\n    getRemainingMessages,\n    checkSubscriptionStatus,\n    createSubscription,\n    upgradeSubscription,\n    cancelSubscription,\n    redirectToSubscription,\n    markTrialAsUsed,\n    trackMembershipUsage,\n    trackFeatureUsage,\n    validateStudentStatus,\n  }\n\n  return (\n    <SubscriptionContext.Provider value={value}>\n      {children}\n    </SubscriptionContext.Provider>\n  )\n}\n\nexport function useSubscription() {\n  const context = useContext(SubscriptionContext)\n  if (context === undefined) {\n    throw new Error('useSubscription must be used within a SubscriptionProvider')\n  }\n  return context\n}"],"names":["SubscriptionProvider","useSubscription","stripePromise","loadStripe","process","env","NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY","SubscriptionContext","createContext","undefined","children","language","t","useLanguage","subscription","setSubscription","useState","trial","setTrial","usage","setUsage","isLoading","setIsLoading","stripe","setStripe","useEffect","initializeStripe","stripeInstance","checkUserSubscription","user","authService","getCurrentUser","isDemoUser","checkSubscriptionStatus","unsubscribe","onAuthStateChange","data","subscriptionData","error","subError","supabase","from","select","eq","id","single","code","logger","trialData","trialError","createSubscription","tier","planType","Error","response","fetch","method","headers","body","JSON","stringify","userId","userEmail","email","userName","name","ok","sessionId","json","redirectToCheckout","toast","cancelSubscription","subscriptionId","stripe_subscription_id","success","redirectToSubscription","window","location","href","ROUTES","upgradeSubscription","newTier","markTrialAsUsed","update","is_used","prev","trackMembershipUsage","benefitType","serviceType","discountApplied","amountSaved","insert","user_id","subscription_id","benefit_type","service_type","discount_applied","amount_saved","trackFeatureUsage","feature","canUseFeature","today","Date","toISOString","split","currentMonth","substring","updatedUsage","dailyMatchesUsed","monthlyMessagesUsed","lastResetDate","premiumEventsUsed","livestreamHoursUsed","upsert","validateStudentStatus","studentEmail","universityId","isValid","usageLimits","hasUnlimitedAccess","dailyReset","monthlyReset","dailyMatches","monthlyMessages","premiumEvents","livestreamHours","hasActiveSubscription","Boolean","status","current_period_end","isInTrial","trial_end","trialDaysRemaining","Math","max","ceil","getTime","subscriptionRequired","membershipTier","effectiveTier","serviceDiscount","canSendMessage","canCreateMatch","canAccessPremiumEvent","canAccessLivestream","getRemainingMatches","dailyUsed","getRemainingMessages","monthlyUsed","value","Provider","context","useContext"],"mappings":"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"}