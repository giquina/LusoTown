import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  Alert,
  ActivityIndicator,
  Dimensions,
} from 'react-native';
import { useTranslation } from 'react-i18next';
import { useFocusEffect } from '@react-navigation/native';
import { Card, IconButton, Menu, Divider } from 'react-native-paper';
import * as DocumentPicker from 'expo-document-picker';
import * as ImagePicker from 'expo-image-picker';
import { Audio } from 'expo-av';
import { Colors, Typography } from '../../constants/Styles';
import { supabase, getCurrentUser } from '../../lib/supabase';
import MessageBubble from './MessageBubble';
import VoiceRecorder from './VoiceRecorder';
import MessageTranslation from './MessageTranslation';
import PortugueseStickers from './PortugueseStickers';
import TypingIndicator from './TypingIndicator';
import LoadingSpinner from '../common/LoadingSpinner';\n\nconst { width } = Dimensions.get('window');\n\ninterface Message {\n  id: string;\n  chat_id: string;\n  sender_id: string;\n  content: string;\n  message_type: 'text' | 'voice' | 'image' | 'sticker' | 'translation';\n  metadata?: any;\n  created_at: string;\n  is_read: boolean;\n  translation?: {\n    original_language: string;\n    translated_language: string;\n    translated_text: string;\n  };\n}\n\ninterface ChatScreenProps {\n  chatId: string;\n  recipientId: string;\n  recipientName: string;\n  recipientAvatar?: string;\n  navigation: any;\n}\n\nexport default function ChatScreen({ \n  chatId, \n  recipientId, \n  recipientName, \n  recipientAvatar,\n  navigation \n}: ChatScreenProps) {\n  const { t } = useTranslation();\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [newMessage, setNewMessage] = useState('');\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSending, setIsSending] = useState(false);\n  const [currentUser, setCurrentUser] = useState<any>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [showStickers, setShowStickers] = useState(false);\n  const [menuVisible, setMenuVisible] = useState(false);\n  const [typingUsers, setTypingUsers] = useState<string[]>([]);\n  const [recording, setRecording] = useState<Audio.Recording | null>(null);\n  \n  const flatListRef = useRef<FlatList>(null);\n  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const messagesSubscription = useRef<any>(null);\n\n  useFocusEffect(\n    useCallback(() => {\n      loadInitialData();\n      subscribeToMessages();\n      markMessagesAsRead();\n      \n      return () => {\n        if (messagesSubscription.current) {\n          messagesSubscription.current.unsubscribe();\n        }\n        if (typingTimeoutRef.current) {\n          clearTimeout(typingTimeoutRef.current);\n        }\n      };\n    }, [chatId])\n  );\n\n  const loadInitialData = async () => {\n    setIsLoading(true);\n    try {\n      await Promise.all([\n        loadUser(),\n        loadMessages(),\n      ]);\n    } catch (error) {\n      console.error('Error loading initial data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadUser = async () => {\n    try {\n      const user = await getCurrentUser();\n      setCurrentUser(user);\n    } catch (error) {\n      console.error('Error loading user:', error);\n    }\n  };\n\n  const loadMessages = async () => {\n    try {\n      const { data, error } = await supabase\n        .from('messages')\n        .select(`\n          *,\n          sender:profiles(id, first_name, last_name, avatar_url)\n        `)\n        .eq('chat_id', chatId)\n        .order('created_at', { ascending: true })\n        .limit(50);\n\n      if (error) throw error;\n      \n      setMessages(data || []);\n      \n      // Scroll to bottom after loading messages\n      setTimeout(() => {\n        flatListRef.current?.scrollToEnd({ animated: false });\n      }, 100);\n    } catch (error) {\n      console.error('Error loading messages:', error);\n      Alert.alert(\n        t('chat.error.title'),\n        t('chat.error.loadMessages')\n      );\n    }\n  };\n\n  const subscribeToMessages = () => {\n    messagesSubscription.current = supabase\n      .channel(`chat-${chatId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'messages',\n          filter: `chat_id=eq.${chatId}`,\n        },\n        (payload) => {\n          const newMessage = payload.new as Message;\n          setMessages(prev => [...prev, newMessage]);\n          \n          // Scroll to bottom when new message arrives\n          setTimeout(() => {\n            flatListRef.current?.scrollToEnd({ animated: true });\n          }, 100);\n          \n          // Mark as read if not from current user\n          if (newMessage.sender_id !== currentUser?.id) {\n            markMessageAsRead(newMessage.id);\n          }\n        }\n      )\n      .on(\n        'postgres_changes',\n        {\n          event: 'UPDATE',\n          schema: 'public',\n          table: 'chat_typing',\n          filter: `chat_id=eq.${chatId}`,\n        },\n        (payload) => {\n          const typingData = payload.new;\n          if (typingData.is_typing && typingData.user_id !== currentUser?.id) {\n            setTypingUsers(prev => \n              prev.includes(typingData.user_id) \n                ? prev \n                : [...prev, typingData.user_id]\n            );\n          } else {\n            setTypingUsers(prev => \n              prev.filter(id => id !== typingData.user_id)\n            );\n          }\n        }\n      )\n      .subscribe();\n  };\n\n  const markMessagesAsRead = async () => {\n    try {\n      await supabase\n        .from('messages')\n        .update({ is_read: true })\n        .eq('chat_id', chatId)\n        .neq('sender_id', currentUser?.id)\n        .eq('is_read', false);\n    } catch (error) {\n      console.error('Error marking messages as read:', error);\n    }\n  };\n\n  const markMessageAsRead = async (messageId: string) => {\n    try {\n      await supabase\n        .from('messages')\n        .update({ is_read: true })\n        .eq('id', messageId);\n    } catch (error) {\n      console.error('Error marking message as read:', error);\n    }\n  };\n\n  const sendMessage = async (content: string, type: string = 'text', metadata?: any) => {\n    if (!content.trim() && type === 'text') return;\n    if (!currentUser) return;\n\n    setIsSending(true);\n    try {\n      const messageData = {\n        chat_id: chatId,\n        sender_id: currentUser.id,\n        content: content.trim(),\n        message_type: type,\n        metadata: metadata || {},\n        created_at: new Date().toISOString(),\n        is_read: false,\n      };\n\n      const { data, error } = await supabase\n        .from('messages')\n        .insert([messageData])\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      // Clear input\n      setNewMessage('');\n      \n      // Stop typing indicator\n      await updateTypingStatus(false);\n      \n      // Scroll to bottom\n      setTimeout(() => {\n        flatListRef.current?.scrollToEnd({ animated: true });\n      }, 100);\n      \n    } catch (error) {\n      console.error('Error sending message:', error);\n      Alert.alert(\n        t('chat.error.title'),\n        t('chat.error.sendMessage')\n      );\n    } finally {\n      setIsSending(false);\n    }\n  };\n\n  const updateTypingStatus = async (isTyping: boolean) => {\n    if (!currentUser) return;\n    \n    try {\n      await supabase\n        .from('chat_typing')\n        .upsert({\n          chat_id: chatId,\n          user_id: currentUser.id,\n          is_typing: isTyping,\n          updated_at: new Date().toISOString(),\n        });\n    } catch (error) {\n      console.error('Error updating typing status:', error);\n    }\n  };\n\n  const handleTextChange = (text: string) => {\n    setNewMessage(text);\n    \n    // Update typing status\n    updateTypingStatus(true);\n    \n    // Clear previous timeout\n    if (typingTimeoutRef.current) {\n      clearTimeout(typingTimeoutRef.current);\n    }\n    \n    // Set timeout to stop typing indicator\n    typingTimeoutRef.current = setTimeout(() => {\n      updateTypingStatus(false);\n    }, 2000);\n  };\n\n  const handleVoiceMessage = async (audioUri: string, duration: number) => {\n    const metadata = {\n      duration,\n      audio_url: audioUri,\n    };\n    \n    await sendMessage(t('chat.voiceMessage'), 'voice', metadata);\n  };\n\n  const handleImageMessage = async () => {\n    try {\n      const result = await ImagePicker.launchImageLibraryAsync({\n        mediaTypes: ImagePicker.MediaTypeOptions.Images,\n        allowsEditing: true,\n        aspect: [4, 3],\n        quality: 0.7,\n      });\n\n      if (!result.canceled && result.assets[0]) {\n        const asset = result.assets[0];\n        \n        // Upload image to Supabase storage\n        const imageUrl = await uploadImage(asset.uri);\n        \n        const metadata = {\n          image_url: imageUrl,\n          width: asset.width,\n          height: asset.height,\n        };\n        \n        await sendMessage(t('chat.imageMessage'), 'image', metadata);\n      }\n    } catch (error) {\n      console.error('Error handling image message:', error);\n      Alert.alert(\n        t('chat.error.title'),\n        t('chat.error.imageUpload')\n      );\n    }\n  };\n\n  const uploadImage = async (uri: string): Promise<string> => {\n    try {\n      const response = await fetch(uri);\n      const blob = await response.blob();\n      \n      const fileName = `chat-image-${Date.now()}.jpg`;\n      const filePath = `${currentUser.id}/${fileName}`;\n      \n      const { data, error } = await supabase.storage\n        .from('chat-images')\n        .upload(filePath, blob, {\n          contentType: 'image/jpeg',\n        });\n        \n      if (error) throw error;\n      \n      const { data: urlData } = supabase.storage\n        .from('chat-images')\n        .getPublicUrl(filePath);\n        \n      return urlData.publicUrl;\n    } catch (error) {\n      console.error('Error uploading image:', error);\n      throw error;\n    }\n  };\n\n  const handleStickerMessage = async (sticker: any) => {\n    const metadata = {\n      sticker_id: sticker.id,\n      sticker_url: sticker.url,\n      cultural_context: sticker.cultural_context,\n    };\n    \n    await sendMessage(sticker.name, 'sticker', metadata);\n    setShowStickers(false);\n  };\n\n  const handleMessageTranslation = async (messageId: string, targetLanguage: string) => {\n    try {\n      // Find the message\n      const message = messages.find(m => m.id === messageId);\n      if (!message) return;\n      \n      // Call translation API (implement your preferred translation service)\n      const translatedText = await translateMessage(message.content, targetLanguage);\n      \n      // Update message with translation\n      const { error } = await supabase\n        .from('messages')\n        .update({\n          translation: {\n            original_language: 'auto',\n            translated_language: targetLanguage,\n            translated_text: translatedText,\n          }\n        })\n        .eq('id', messageId);\n        \n      if (error) throw error;\n      \n      // Update local state\n      setMessages(prev => prev.map(m => \n        m.id === messageId \n          ? {\n              ...m,\n              translation: {\n                original_language: 'auto',\n                translated_language: targetLanguage,\n                translated_text: translatedText,\n              }\n            }\n          : m\n      ));\n      \n    } catch (error) {\n      console.error('Error translating message:', error);\n      Alert.alert(\n        t('chat.error.title'),\n        t('chat.error.translation')\n      );\n    }\n  };\n\n  const translateMessage = async (text: string, targetLanguage: string): Promise<string> => {\n    // Implement your preferred translation service\n    // This is a placeholder - you would integrate with Google Translate, Azure Translator, etc.\n    try {\n      const response = await fetch('https://api.translate.service.com/translate', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.EXPO_PUBLIC_TRANSLATION_API_KEY}`,\n        },\n        body: JSON.stringify({\n          text,\n          target_language: targetLanguage,\n        }),\n      });\n      \n      const data = await response.json();\n      return data.translated_text;\n    } catch (error) {\n      console.error('Translation API error:', error);\n      return text; // Return original text if translation fails\n    }\n  };\n\n  const renderMessage = ({ item, index }: { item: Message; index: number }) => {\n    const isCurrentUser = item.sender_id === currentUser?.id;\n    const showAvatar = !isCurrentUser && (\n      index === messages.length - 1 || \n      messages[index + 1]?.sender_id !== item.sender_id\n    );\n    \n    return (\n      <MessageBubble\n        message={item}\n        isCurrentUser={isCurrentUser}\n        showAvatar={showAvatar}\n        recipientAvatar={recipientAvatar}\n        onTranslate={handleMessageTranslation}\n      />\n    );\n  };\n\n  if (isLoading) {\n    return <LoadingSpinner message={t('chat.loading')} />;\n  }\n\n  return (\n    <KeyboardAvoidingView\n      style={styles.container}\n      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}\n    >\n      {/* Messages List */}\n      <FlatList\n        ref={flatListRef}\n        data={messages}\n        renderItem={renderMessage}\n        keyExtractor={(item) => item.id}\n        style={styles.messagesList}\n        contentContainerStyle={styles.messagesContent}\n        showsVerticalScrollIndicator={false}\n        onContentSizeChange={() => {\n          flatListRef.current?.scrollToEnd({ animated: true });\n        }}\n      />\n\n      {/* Typing Indicator */}\n      {typingUsers.length > 0 && (\n        <TypingIndicator userName={recipientName} />\n      )}\n\n      {/* Portuguese Stickers */}\n      {showStickers && (\n        <PortugueseStickers\n          onStickerSelect={handleStickerMessage}\n          onClose={() => setShowStickers(false)}\n        />\n      )}\n\n      {/* Input Area */}\n      <View style={styles.inputContainer}>\n        <View style={styles.inputRow}>\n          {/* Attachment Menu */}\n          <Menu\n            visible={menuVisible}\n            onDismiss={() => setMenuVisible(false)}\n            anchor={\n              <IconButton\n                icon=\"plus\"\n                size={24}\n                iconColor={Colors.primary}\n                onPress={() => setMenuVisible(true)}\n              />\n            }\n          >\n            <Menu.Item\n              onPress={() => {\n                setMenuVisible(false);\n                handleImageMessage();\n              }}\n              title={t('chat.attachments.image')}\n              leadingIcon=\"image\"\n            />\n            <Menu.Item\n              onPress={() => {\n                setMenuVisible(false);\n                setShowStickers(true);\n              }}\n              title={t('chat.attachments.stickers')}\n              leadingIcon=\"sticker-emoji\"\n            />\n            <Divider />\n            <Menu.Item\n              onPress={() => {\n                setMenuVisible(false);\n                // Handle file attachment\n              }}\n              title={t('chat.attachments.file')}\n              leadingIcon=\"file\"\n            />\n          </Menu>\n\n          {/* Text Input */}\n          <TextInput\n            style={styles.textInput}\n            value={newMessage}\n            onChangeText={handleTextChange}\n            placeholder={t('chat.input.placeholder')}\n            placeholderTextColor={Colors.textSecondary}\n            multiline\n            maxLength={1000}\n            returnKeyType=\"default\"\n            blurOnSubmit={false}\n          />\n\n          {/* Voice Recorder / Send Button */}\n          {newMessage.trim() ? (\n            <TouchableOpacity\n              style={styles.sendButton}\n              onPress={() => sendMessage(newMessage)}\n              disabled={isSending}\n            >\n              {isSending ? (\n                <ActivityIndicator size=\"small\" color=\"white\" />\n              ) : (\n                <Text style={styles.sendIcon}>→</Text>\n              )}\n            </TouchableOpacity>\n          ) : (\n            <VoiceRecorder\n              onRecordingComplete={handleVoiceMessage}\n              isRecording={isRecording}\n              setIsRecording={setIsRecording}\n            />\n          )}\n        </View>\n      </View>\n    </KeyboardAvoidingView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: Colors.background,\n  },\n  messagesList: {\n    flex: 1,\n  },\n  messagesContent: {\n    padding: 16,\n    paddingBottom: 8,\n  },\n  inputContainer: {\n    backgroundColor: Colors.surface,\n    borderTopWidth: 1,\n    borderTopColor: Colors.border,\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n  },\n  inputRow: {\n    flexDirection: 'row',\n    alignItems: 'flex-end',\n    gap: 8,\n  },\n  textInput: {\n    flex: 1,\n    backgroundColor: Colors.background,\n    borderRadius: 20,\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    maxHeight: 100,\n    ...Typography.body,\n    color: Colors.text,\n    borderWidth: 1,\n    borderColor: Colors.border,\n  },\n  sendButton: {\n    backgroundColor: Colors.primary,\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  sendIcon: {\n    color: 'white',\n    fontSize: 18,\n    fontWeight: 'bold',\n  },\n});"